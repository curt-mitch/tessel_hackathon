   1               		.file	"ambient-attx4.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               	.global	__vector_9
  11               	__vector_9:
  12               	.LFB1:
  13               		.file 1 "spi_via_usi_driver.c"
   1:spi_via_usi_driver.c **** // This file has been prepared for Doxygen automatic documentation generation.
   2:spi_via_usi_driver.c **** 
   3:spi_via_usi_driver.c **** /*! \file ********************************************************************
   4:spi_via_usi_driver.c **** 
   5:spi_via_usi_driver.c **** *
   6:spi_via_usi_driver.c **** 
   7:spi_via_usi_driver.c **** * Atmel Corporation
   8:spi_via_usi_driver.c **** 
   9:spi_via_usi_driver.c **** *
  10:spi_via_usi_driver.c **** 
  11:spi_via_usi_driver.c **** * \li File:               spi_via_usi_driver.c
  12:spi_via_usi_driver.c **** 
  13:spi_via_usi_driver.c **** * \li Compiler:           IAR EWAAVR 3.10c
  14:spi_via_usi_driver.c **** 
  15:spi_via_usi_driver.c **** * \li Support mail:       avr@atmel.com
  16:spi_via_usi_driver.c **** 
  17:spi_via_usi_driver.c **** *
  18:spi_via_usi_driver.c **** 
  19:spi_via_usi_driver.c **** * \li Supported devices:  All devices with Universal Serial Interface (USI)
  20:spi_via_usi_driver.c **** 
  21:spi_via_usi_driver.c **** *                         capabilities can be used.
  22:spi_via_usi_driver.c **** 
  23:spi_via_usi_driver.c **** *                         The example is written for ATmega169.
  24:spi_via_usi_driver.c **** 
  25:spi_via_usi_driver.c **** *
  26:spi_via_usi_driver.c **** 
  27:spi_via_usi_driver.c **** * \li AppNote:            AVR319 - Using the USI module for SPI communication.
  28:spi_via_usi_driver.c **** 
  29:spi_via_usi_driver.c **** *
  30:spi_via_usi_driver.c **** 
  31:spi_via_usi_driver.c **** * \li Description:        Example on how to use the USI module for communicating
  32:spi_via_usi_driver.c **** 
  33:spi_via_usi_driver.c **** *                         with SPI compatible devices. The functions and variables
  34:spi_via_usi_driver.c **** 
  35:spi_via_usi_driver.c **** *                         prefixed 'spiX_' can be renamed to be able to use several
  36:spi_via_usi_driver.c **** 
  37:spi_via_usi_driver.c **** *                         spi drivers (using different interfaces) with similar names.
  38:spi_via_usi_driver.c **** 
  39:spi_via_usi_driver.c **** *                         Some basic SPI knowledge is assumed.
  40:spi_via_usi_driver.c **** 
  41:spi_via_usi_driver.c **** *
  42:spi_via_usi_driver.c **** 
  43:spi_via_usi_driver.c **** *                         $Revision: 1.4 $
  44:spi_via_usi_driver.c **** 
  45:spi_via_usi_driver.c **** *                         $Date: Monday, September 13, 2004 12:08:54 UTC $
  46:spi_via_usi_driver.c **** 
  47:spi_via_usi_driver.c **** ****************************************************************************/
  48:spi_via_usi_driver.c **** 
  49:spi_via_usi_driver.c **** #include <avr/io.h>
  50:spi_via_usi_driver.c **** 
  51:spi_via_usi_driver.c **** #include <avr/interrupt.h>
  52:spi_via_usi_driver.c **** 
  53:spi_via_usi_driver.c **** 
  54:spi_via_usi_driver.c **** 
  55:spi_via_usi_driver.c **** 
  56:spi_via_usi_driver.c **** 
  57:spi_via_usi_driver.c **** 
  58:spi_via_usi_driver.c **** 
  59:spi_via_usi_driver.c **** /* USI port and pin definitions.
  60:spi_via_usi_driver.c ****  */
  61:spi_via_usi_driver.c **** #define USI_OUT_REG	PORTA	//!< USI port output register.
  62:spi_via_usi_driver.c **** #define USI_IN_REG	PINA	//!< USI port input register.
  63:spi_via_usi_driver.c **** #define USI_DIR_REG	DDRA	//!< USI port direction register.
  64:spi_via_usi_driver.c **** #define USI_CLOCK_PIN	PA4	//!< USI clock I/O pin.
  65:spi_via_usi_driver.c **** #define USI_DATAIN_PIN	PA6	//!< USI data input pin.
  66:spi_via_usi_driver.c **** #define USI_DATAOUT_PIN	PA5	//!< USI data output pin.
  67:spi_via_usi_driver.c **** 
  68:spi_via_usi_driver.c **** 
  69:spi_via_usi_driver.c **** 
  70:spi_via_usi_driver.c **** 
  71:spi_via_usi_driver.c **** 
  72:spi_via_usi_driver.c **** 
  73:spi_via_usi_driver.c **** 
  74:spi_via_usi_driver.c **** 
  75:spi_via_usi_driver.c **** 
  76:spi_via_usi_driver.c **** /*  Speed configuration:
  77:spi_via_usi_driver.c **** 
  78:spi_via_usi_driver.c ****  *  Bits per second = CPUSPEED / PRESCALER / (COMPAREVALUE+1) / 2.
  79:spi_via_usi_driver.c **** 
  80:spi_via_usi_driver.c ****  *  Maximum = CPUSPEED / 64.
  81:spi_via_usi_driver.c **** 
  82:spi_via_usi_driver.c ****  */
  83:spi_via_usi_driver.c **** 
  84:spi_via_usi_driver.c **** #define TC0_PRESCALER_VALUE 64	//!< Must be 1, 8, 64, 256 or 1024.
  85:spi_via_usi_driver.c **** 
  86:spi_via_usi_driver.c **** #define TC0_COMPARE_VALUE   1	//!< Must be 0 to 255. Minimum 31 with prescaler CLK/1.
  87:spi_via_usi_driver.c **** 
  88:spi_via_usi_driver.c **** 
  89:spi_via_usi_driver.c **** 
  90:spi_via_usi_driver.c **** 
  91:spi_via_usi_driver.c **** 
  92:spi_via_usi_driver.c **** 
  93:spi_via_usi_driver.c **** 
  94:spi_via_usi_driver.c **** 
  95:spi_via_usi_driver.c **** 
  96:spi_via_usi_driver.c **** /*  Prescaler value converted to bit settings.
  97:spi_via_usi_driver.c **** 
  98:spi_via_usi_driver.c ****  */
  99:spi_via_usi_driver.c **** 
 100:spi_via_usi_driver.c **** #if TC0_PRESCALER_VALUE == 1
 101:spi_via_usi_driver.c **** 
 102:spi_via_usi_driver.c **** 	#define TC0_PS_SETTING (1<<CS00)
 103:spi_via_usi_driver.c **** 
 104:spi_via_usi_driver.c **** #elif TC0_PRESCALER_VALUE == 8
 105:spi_via_usi_driver.c **** 
 106:spi_via_usi_driver.c **** 	#define TC0_PS_SETTING (1<<CS01)
 107:spi_via_usi_driver.c **** 
 108:spi_via_usi_driver.c **** #elif TC0_PRESCALER_VALUE == 64
 109:spi_via_usi_driver.c **** 
 110:spi_via_usi_driver.c **** 	#define TC0_PS_SETTING (1<<CS01)|(1<<CS00)
 111:spi_via_usi_driver.c **** 
 112:spi_via_usi_driver.c **** #elif TC0_PRESCALER_VALUE == 256
 113:spi_via_usi_driver.c **** 
 114:spi_via_usi_driver.c **** 	#define TC0_PS_SETTING (1<<CS02)
 115:spi_via_usi_driver.c **** 
 116:spi_via_usi_driver.c **** #elif TC0_PRESCALER_VALUE == 1024
 117:spi_via_usi_driver.c **** 
 118:spi_via_usi_driver.c **** 	#define TC0_PS_SETTING (1<<CS02)|(1<<CS00)
 119:spi_via_usi_driver.c **** 
 120:spi_via_usi_driver.c **** #else
 121:spi_via_usi_driver.c **** 
 122:spi_via_usi_driver.c **** 	#error Invalid T/C0 prescaler setting.
 123:spi_via_usi_driver.c **** 
 124:spi_via_usi_driver.c **** #endif
 125:spi_via_usi_driver.c **** 
 126:spi_via_usi_driver.c **** 
 127:spi_via_usi_driver.c **** 
 128:spi_via_usi_driver.c **** 
 129:spi_via_usi_driver.c **** 
 130:spi_via_usi_driver.c **** 
 131:spi_via_usi_driver.c **** 
 132:spi_via_usi_driver.c **** /*! \brief  Data input register buffer.
 133:spi_via_usi_driver.c **** 
 134:spi_via_usi_driver.c ****  *
 135:spi_via_usi_driver.c **** 
 136:spi_via_usi_driver.c ****  *  Incoming bytes are stored in this byte until the next transfer is complete.
 137:spi_via_usi_driver.c **** 
 138:spi_via_usi_driver.c ****  *  This byte can be used the same way as the SPI data register in the native
 139:spi_via_usi_driver.c **** 
 140:spi_via_usi_driver.c ****  *  SPI module, which means that the byte must be read before the next transfer
 141:spi_via_usi_driver.c **** 
 142:spi_via_usi_driver.c ****  *  completes and overwrites the current value.
 143:spi_via_usi_driver.c **** 
 144:spi_via_usi_driver.c ****  */
 145:spi_via_usi_driver.c **** 
 146:spi_via_usi_driver.c **** unsigned char storedUSIDR;
 147:spi_via_usi_driver.c **** 
 148:spi_via_usi_driver.c **** 
 149:spi_via_usi_driver.c **** 
 150:spi_via_usi_driver.c **** 
 151:spi_via_usi_driver.c **** 
 152:spi_via_usi_driver.c **** 
 153:spi_via_usi_driver.c **** 
 154:spi_via_usi_driver.c **** /*! \brief  Driver status bit structure.
 155:spi_via_usi_driver.c **** 
 156:spi_via_usi_driver.c ****  *
 157:spi_via_usi_driver.c **** 
 158:spi_via_usi_driver.c ****  *  This struct contains status flags for the driver.
 159:spi_via_usi_driver.c **** 
 160:spi_via_usi_driver.c ****  *  The flags have the same meaning as the corresponding status flags
 161:spi_via_usi_driver.c **** 
 162:spi_via_usi_driver.c ****  *  for the native SPI module. The flags should not be changed by the user.
 163:spi_via_usi_driver.c **** 
 164:spi_via_usi_driver.c ****  *  The driver takes care of updating the flags when required.
 165:spi_via_usi_driver.c **** 
 166:spi_via_usi_driver.c ****  */
 167:spi_via_usi_driver.c **** 
 168:spi_via_usi_driver.c **** struct usidriverStatus_t {
 169:spi_via_usi_driver.c **** 
 170:spi_via_usi_driver.c **** 	unsigned char masterMode : 1;       //!< True if in master mode.
 171:spi_via_usi_driver.c **** 
 172:spi_via_usi_driver.c **** 	unsigned char transferComplete : 1; //!< True when transfer completed.
 173:spi_via_usi_driver.c **** 
 174:spi_via_usi_driver.c **** 	unsigned char writeCollision : 1;   //!< True if put attempted during transfer.
 175:spi_via_usi_driver.c **** 
 176:spi_via_usi_driver.c **** };
 177:spi_via_usi_driver.c **** 
 178:spi_via_usi_driver.c **** 
 179:spi_via_usi_driver.c **** 
 180:spi_via_usi_driver.c **** volatile struct usidriverStatus_t spiX_status; //!< The driver status bits.
 181:spi_via_usi_driver.c **** 
 182:spi_via_usi_driver.c **** 
 183:spi_via_usi_driver.c **** 
 184:spi_via_usi_driver.c **** 
 185:spi_via_usi_driver.c **** 
 186:spi_via_usi_driver.c **** 
 187:spi_via_usi_driver.c **** 
 188:spi_via_usi_driver.c **** /*! \brief  Timer/Counter 0 Compare Match Interrupt handler.
 189:spi_via_usi_driver.c **** 
 190:spi_via_usi_driver.c ****  *
 191:spi_via_usi_driver.c **** 
 192:spi_via_usi_driver.c ****  *  This interrupt handler is only enabled when transferring data
 193:spi_via_usi_driver.c **** 
 194:spi_via_usi_driver.c ****  *  in master mode. It toggles the USI clock pin, i.e. two interrupts
 195:spi_via_usi_driver.c **** 
 196:spi_via_usi_driver.c ****  *  results in one clock period on the clock pin and for the USI counter.
 197:spi_via_usi_driver.c **** 
 198:spi_via_usi_driver.c ****  */
 199:spi_via_usi_driver.c **** 
 200:spi_via_usi_driver.c **** ISR(TIM0_COMPA_vect)
 201:spi_via_usi_driver.c **** {
  14               		.loc 1 201 0
  15               		.cfi_startproc
  16 0000 1F92      		push r1
  17               	.LCFI0:
  18               		.cfi_def_cfa_offset 3
  19               		.cfi_offset 1, -2
  20 0002 0F92      		push r0
  21               	.LCFI1:
  22               		.cfi_def_cfa_offset 4
  23               		.cfi_offset 0, -3
  24 0004 0FB6      		in r0,__SREG__
  25 0006 0F92      		push r0
  26 0008 1124      		clr __zero_reg__
  27               	/* prologue: Signal */
  28               	/* frame size = 0 */
  29               	/* stack size = 3 */
  30               	.L__stack_usage = 3
 202:spi_via_usi_driver.c **** 	USICR |= (1<<USITC);	// Toggle clock output pin.
  31               		.loc 1 202 0
  32 000a 689A      		sbi 0xd,0
  33               	/* epilogue start */
 203:spi_via_usi_driver.c **** }
  34               		.loc 1 203 0
  35 000c 0F90      		pop r0
  36 000e 0FBE      		out __SREG__,r0
  37 0010 0F90      		pop r0
  38 0012 1F90      		pop r1
  39 0014 1895      		reti
  40               		.cfi_endproc
  41               	.LFE1:
  43               	.global	__vector_16
  45               	__vector_16:
  46               	.LFB2:
 204:spi_via_usi_driver.c **** 
 205:spi_via_usi_driver.c **** 
 206:spi_via_usi_driver.c **** 
 207:spi_via_usi_driver.c **** 
 208:spi_via_usi_driver.c **** 
 209:spi_via_usi_driver.c **** 
 210:spi_via_usi_driver.c **** 
 211:spi_via_usi_driver.c **** /*! \brief  USI Timer Overflow Interrupt handler.
 212:spi_via_usi_driver.c **** 
 213:spi_via_usi_driver.c ****  *
 214:spi_via_usi_driver.c **** 
 215:spi_via_usi_driver.c ****  *  This handler disables the compare match interrupt if in master mode.
 216:spi_via_usi_driver.c **** 
 217:spi_via_usi_driver.c ****  *  When the USI counter overflows, a byte has been transferred, and we
 218:spi_via_usi_driver.c **** 
 219:spi_via_usi_driver.c ****  *  have to stop the timer tick.
 220:spi_via_usi_driver.c **** 
 221:spi_via_usi_driver.c ****  *  For all modes the USIDR contents are stored and flags are updated.
 222:spi_via_usi_driver.c **** 
 223:spi_via_usi_driver.c ****  */
 224:spi_via_usi_driver.c **** 
 225:spi_via_usi_driver.c **** ISR(USI_OVF_vect)
 226:spi_via_usi_driver.c **** 
 227:spi_via_usi_driver.c **** {
  47               		.loc 1 227 0
  48               		.cfi_startproc
  49 0016 1F92      		push r1
  50               	.LCFI2:
  51               		.cfi_def_cfa_offset 3
  52               		.cfi_offset 1, -2
  53 0018 0F92      		push r0
  54               	.LCFI3:
  55               		.cfi_def_cfa_offset 4
  56               		.cfi_offset 0, -3
  57 001a 0FB6      		in r0,__SREG__
  58 001c 0F92      		push r0
  59 001e 1124      		clr __zero_reg__
  60 0020 8F93      		push r24
  61               	.LCFI4:
  62               		.cfi_def_cfa_offset 5
  63               		.cfi_offset 24, -4
  64               	/* prologue: Signal */
  65               	/* frame size = 0 */
  66               	/* stack size = 4 */
  67               	.L__stack_usage = 4
 228:spi_via_usi_driver.c **** 
 229:spi_via_usi_driver.c **** 	// Master must now disable the compare match interrupt
 230:spi_via_usi_driver.c **** 
 231:spi_via_usi_driver.c **** 	// to prevent more USI counter clocks.
 232:spi_via_usi_driver.c **** 
 233:spi_via_usi_driver.c **** 	if( spiX_status.masterMode == 1 ) {
  68               		.loc 1 233 0
  69 0022 8091 0000 		lds r24,spiX_status
  70 0026 80FF      		sbrs r24,0
  71 0028 00C0      		rjmp .L3
 234:spi_via_usi_driver.c **** 
 235:spi_via_usi_driver.c **** 		TIMSK0 &= ~(1<<OCIE0A);
  72               		.loc 1 235 0
  73 002a 89B7      		in r24,0x39
  74 002c 8D7F      		andi r24,lo8(-3)
  75 002e 89BF      		out 0x39,r24
  76               	.L3:
 236:spi_via_usi_driver.c **** 
 237:spi_via_usi_driver.c **** 	}
 238:spi_via_usi_driver.c **** 
 239:spi_via_usi_driver.c **** 	
 240:spi_via_usi_driver.c **** 
 241:spi_via_usi_driver.c **** 	// Update flags and clear USI counter
 242:spi_via_usi_driver.c **** 
 243:spi_via_usi_driver.c **** 	USISR = (1<<USIOIF);
  77               		.loc 1 243 0
  78 0030 80E4      		ldi r24,lo8(64)
  79 0032 8EB9      		out 0xe,r24
 244:spi_via_usi_driver.c **** 
 245:spi_via_usi_driver.c **** 	spiX_status.transferComplete = 1;
  80               		.loc 1 245 0
  81 0034 8091 0000 		lds r24,spiX_status
  82 0038 8260      		ori r24,lo8(1<<1)
  83 003a 8093 0000 		sts spiX_status,r24
 246:spi_via_usi_driver.c **** 
 247:spi_via_usi_driver.c **** 
 248:spi_via_usi_driver.c **** 
 249:spi_via_usi_driver.c **** 	// Copy USIDR to buffer to prevent overwrite on next transfer.
 250:spi_via_usi_driver.c **** 
 251:spi_via_usi_driver.c **** 	storedUSIDR = USIDR;
  84               		.loc 1 251 0
  85 003e 8FB1      		in r24,0xf
  86 0040 8093 0000 		sts storedUSIDR,r24
  87               	/* epilogue start */
 252:spi_via_usi_driver.c **** 
 253:spi_via_usi_driver.c **** }
  88               		.loc 1 253 0
  89 0044 8F91      		pop r24
  90 0046 0F90      		pop r0
  91 0048 0FBE      		out __SREG__,r0
  92 004a 0F90      		pop r0
  93 004c 1F90      		pop r1
  94 004e 1895      		reti
  95               		.cfi_endproc
  96               	.LFE2:
  98               	.global	spiX_initmaster
 100               	spiX_initmaster:
 101               	.LFB3:
 254:spi_via_usi_driver.c **** 
 255:spi_via_usi_driver.c **** 
 256:spi_via_usi_driver.c **** 
 257:spi_via_usi_driver.c **** 
 258:spi_via_usi_driver.c **** 
 259:spi_via_usi_driver.c **** 
 260:spi_via_usi_driver.c **** 
 261:spi_via_usi_driver.c **** /*! \brief  Initialize USI as SPI master.
 262:spi_via_usi_driver.c **** 
 263:spi_via_usi_driver.c ****  *
 264:spi_via_usi_driver.c **** 
 265:spi_via_usi_driver.c ****  *  This function sets up all pin directions and module configurations.
 266:spi_via_usi_driver.c **** 
 267:spi_via_usi_driver.c ****  *  Use this function initially or when changing from slave to master mode.
 268:spi_via_usi_driver.c **** 
 269:spi_via_usi_driver.c ****  *  Note that the stored USIDR value is cleared.
 270:spi_via_usi_driver.c **** 
 271:spi_via_usi_driver.c ****  *
 272:spi_via_usi_driver.c **** 
 273:spi_via_usi_driver.c ****  *  \param spi_mode  Required SPI mode, must be 0 or 1.
 274:spi_via_usi_driver.c **** 
 275:spi_via_usi_driver.c ****  */
 276:spi_via_usi_driver.c **** 
 277:spi_via_usi_driver.c **** void spiX_initmaster( char spi_mode )
 278:spi_via_usi_driver.c **** 
 279:spi_via_usi_driver.c **** {
 102               		.loc 1 279 0
 103               		.cfi_startproc
 104               	.LVL0:
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
 280:spi_via_usi_driver.c **** 
 281:spi_via_usi_driver.c **** 	// Configure port directions.
 282:spi_via_usi_driver.c **** 
 283:spi_via_usi_driver.c **** 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Outputs.
 109               		.loc 1 283 0
 110 0050 9AB3      		in r25,0x1a
 111 0052 9063      		ori r25,lo8(48)
 112 0054 9ABB      		out 0x1a,r25
 284:spi_via_usi_driver.c **** 
 285:spi_via_usi_driver.c **** 	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                      // Inputs.
 113               		.loc 1 285 0
 114 0056 D698      		cbi 0x1a,6
 286:spi_via_usi_driver.c **** 
 287:spi_via_usi_driver.c **** 	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                       // Pull-ups.
 115               		.loc 1 287 0
 116 0058 DE9A      		sbi 0x1b,6
 288:spi_via_usi_driver.c **** 
 289:spi_via_usi_driver.c **** 	
 290:spi_via_usi_driver.c **** 
 291:spi_via_usi_driver.c **** 	// Configure USI to 3-wire master mode with overflow interrupt.
 292:spi_via_usi_driver.c **** 
 293:spi_via_usi_driver.c **** 	USICR = (1<<USIOIE) | (1<<USIWM0) |
 294:spi_via_usi_driver.c **** 
 295:spi_via_usi_driver.c **** 	        (1<<USICS1) | (spi_mode<<USICS0) |
 117               		.loc 1 295 0
 118 005a 90E0      		ldi r25,0
 119 005c 880F      		lsl r24
 120 005e 991F      		rol r25
 121 0060 880F      		lsl r24
 122 0062 991F      		rol r25
 123               	.LVL1:
 293:spi_via_usi_driver.c **** 	USICR = (1<<USIOIE) | (1<<USIWM0) |
 124               		.loc 1 293 0
 125 0064 8A65      		ori r24,90
 126 0066 8DB9      		out 0xd,r24
 296:spi_via_usi_driver.c **** 
 297:spi_via_usi_driver.c **** 	        (1<<USICLK);
 298:spi_via_usi_driver.c **** 
 299:spi_via_usi_driver.c **** 
 300:spi_via_usi_driver.c **** 	// Enable 'Clear Timer on Compare match' and init prescaler.
 301:spi_via_usi_driver.c **** 
 302:spi_via_usi_driver.c **** 	// This made it impossible to get interrupts for some reason
 303:spi_via_usi_driver.c **** 	// TCCR0A = (1<<WGM01);
 304:spi_via_usi_driver.c **** 	TCCR0B = TC0_PS_SETTING;
 127               		.loc 1 304 0
 128 0068 83E0      		ldi r24,lo8(3)
 129 006a 83BF      		out 0x33,r24
 305:spi_via_usi_driver.c **** 	
 306:spi_via_usi_driver.c **** 
 307:spi_via_usi_driver.c **** 	// Init Output Compare Register.
 308:spi_via_usi_driver.c **** 
 309:spi_via_usi_driver.c **** 	OCR0A = TC0_COMPARE_VALUE;
 130               		.loc 1 309 0
 131 006c 81E0      		ldi r24,lo8(1)
 132 006e 86BF      		out 0x36,r24
 310:spi_via_usi_driver.c **** 
 311:spi_via_usi_driver.c **** 	
 312:spi_via_usi_driver.c **** 
 313:spi_via_usi_driver.c **** 	// Init driver status register.
 314:spi_via_usi_driver.c **** 
 315:spi_via_usi_driver.c **** 	spiX_status.masterMode       = 1;
 133               		.loc 1 315 0
 134 0070 8091 0000 		lds r24,spiX_status
 135 0074 8160      		ori r24,lo8(1<<0)
 136 0076 8093 0000 		sts spiX_status,r24
 316:spi_via_usi_driver.c **** 
 317:spi_via_usi_driver.c **** 	spiX_status.transferComplete = 0;
 137               		.loc 1 317 0
 138 007a 8091 0000 		lds r24,spiX_status
 139 007e 8D7F      		andi r24,lo8(~(1<<1))
 140 0080 8093 0000 		sts spiX_status,r24
 318:spi_via_usi_driver.c **** 
 319:spi_via_usi_driver.c **** 	spiX_status.writeCollision   = 0;
 141               		.loc 1 319 0
 142 0084 8091 0000 		lds r24,spiX_status
 143 0088 8B7F      		andi r24,lo8(~(1<<2))
 144 008a 8093 0000 		sts spiX_status,r24
 320:spi_via_usi_driver.c **** 	
 321:spi_via_usi_driver.c **** 
 322:spi_via_usi_driver.c **** 	storedUSIDR = 0;
 145               		.loc 1 322 0
 146 008e 1092 0000 		sts storedUSIDR,__zero_reg__
 147 0092 0895      		ret
 148               		.cfi_endproc
 149               	.LFE3:
 151               	.global	spiX_initslave
 153               	spiX_initslave:
 154               	.LFB4:
 323:spi_via_usi_driver.c **** 
 324:spi_via_usi_driver.c **** }
 325:spi_via_usi_driver.c **** 
 326:spi_via_usi_driver.c **** 
 327:spi_via_usi_driver.c **** 
 328:spi_via_usi_driver.c **** 
 329:spi_via_usi_driver.c **** 
 330:spi_via_usi_driver.c **** 
 331:spi_via_usi_driver.c **** 
 332:spi_via_usi_driver.c **** /*! \brief  Initialize USI as SPI slave.
 333:spi_via_usi_driver.c **** 
 334:spi_via_usi_driver.c ****  *
 335:spi_via_usi_driver.c **** 
 336:spi_via_usi_driver.c ****  *  This function sets up all pin directions and module configurations.
 337:spi_via_usi_driver.c **** 
 338:spi_via_usi_driver.c ****  *  Use this function initially or when changing from master to slave mode.
 339:spi_via_usi_driver.c **** 
 340:spi_via_usi_driver.c ****  *  Note that the stored USIDR value is cleared.
 341:spi_via_usi_driver.c **** 
 342:spi_via_usi_driver.c ****  *
 343:spi_via_usi_driver.c **** 
 344:spi_via_usi_driver.c ****  *  \param spi_mode  Required SPI mode, must be 0 or 1.
 345:spi_via_usi_driver.c **** 
 346:spi_via_usi_driver.c ****  */
 347:spi_via_usi_driver.c **** 
 348:spi_via_usi_driver.c **** void spiX_initslave( char spi_mode )
 349:spi_via_usi_driver.c **** 
 350:spi_via_usi_driver.c **** {
 155               		.loc 1 350 0
 156               		.cfi_startproc
 157               	.LVL2:
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 351:spi_via_usi_driver.c **** 
 352:spi_via_usi_driver.c **** 	// Configure port directions.
 353:spi_via_usi_driver.c **** 
 354:spi_via_usi_driver.c **** 	USI_DIR_REG |= (1<<USI_DATAOUT_PIN);                      // Outputs.
 162               		.loc 1 354 0
 163 0094 D59A      		sbi 0x1a,5
 355:spi_via_usi_driver.c **** 
 356:spi_via_usi_driver.c **** 	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN); // Inputs.
 164               		.loc 1 356 0
 165 0096 D698      		cbi 0x1a,6
 357:spi_via_usi_driver.c **** 
 358:spi_via_usi_driver.c **** 	USI_OUT_REG |= (1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN);  // Pull-ups.
 166               		.loc 1 358 0
 167 0098 9BB3      		in r25,0x1b
 168 009a 9065      		ori r25,lo8(80)
 169 009c 9BBB      		out 0x1b,r25
 359:spi_via_usi_driver.c **** 
 360:spi_via_usi_driver.c **** 	
 361:spi_via_usi_driver.c **** 
 362:spi_via_usi_driver.c **** 	// Configure USI to 3-wire slave mode with overflow interrupt.
 363:spi_via_usi_driver.c **** 
 364:spi_via_usi_driver.c **** 	USICR = (1<<USIOIE) | (1<<USIWM0) |
 365:spi_via_usi_driver.c **** 
 366:spi_via_usi_driver.c **** 	        (1<<USICS1) | (spi_mode<<USICS0);
 170               		.loc 1 366 0
 171 009e 90E0      		ldi r25,0
 172 00a0 880F      		lsl r24
 173 00a2 991F      		rol r25
 174 00a4 880F      		lsl r24
 175 00a6 991F      		rol r25
 176               	.LVL3:
 364:spi_via_usi_driver.c **** 	USICR = (1<<USIOIE) | (1<<USIWM0) |
 177               		.loc 1 364 0
 178 00a8 8865      		ori r24,88
 179 00aa 8DB9      		out 0xd,r24
 367:spi_via_usi_driver.c **** 
 368:spi_via_usi_driver.c **** 	
 369:spi_via_usi_driver.c **** 
 370:spi_via_usi_driver.c **** 	// Init driver status register.
 371:spi_via_usi_driver.c **** 
 372:spi_via_usi_driver.c **** 	spiX_status.masterMode       = 0;
 180               		.loc 1 372 0
 181 00ac 8091 0000 		lds r24,spiX_status
 182 00b0 8E7F      		andi r24,lo8(~(1<<0))
 183 00b2 8093 0000 		sts spiX_status,r24
 373:spi_via_usi_driver.c **** 
 374:spi_via_usi_driver.c **** 	spiX_status.transferComplete = 0;
 184               		.loc 1 374 0
 185 00b6 8091 0000 		lds r24,spiX_status
 186 00ba 8D7F      		andi r24,lo8(~(1<<1))
 187 00bc 8093 0000 		sts spiX_status,r24
 375:spi_via_usi_driver.c **** 
 376:spi_via_usi_driver.c **** 	spiX_status.writeCollision   = 0;
 188               		.loc 1 376 0
 189 00c0 8091 0000 		lds r24,spiX_status
 190 00c4 8B7F      		andi r24,lo8(~(1<<2))
 191 00c6 8093 0000 		sts spiX_status,r24
 377:spi_via_usi_driver.c **** 
 378:spi_via_usi_driver.c **** 	
 379:spi_via_usi_driver.c **** 
 380:spi_via_usi_driver.c **** 	storedUSIDR = 0;
 192               		.loc 1 380 0
 193 00ca 1092 0000 		sts storedUSIDR,__zero_reg__
 194 00ce 0895      		ret
 195               		.cfi_endproc
 196               	.LFE4:
 198               	.global	spiX_put
 200               	spiX_put:
 201               	.LFB5:
 381:spi_via_usi_driver.c **** 
 382:spi_via_usi_driver.c **** }
 383:spi_via_usi_driver.c **** 
 384:spi_via_usi_driver.c **** 
 385:spi_via_usi_driver.c **** 
 386:spi_via_usi_driver.c **** 
 387:spi_via_usi_driver.c **** 
 388:spi_via_usi_driver.c **** 
 389:spi_via_usi_driver.c **** 
 390:spi_via_usi_driver.c **** /*! \brief  Put one byte on bus.
 391:spi_via_usi_driver.c **** 
 392:spi_via_usi_driver.c ****  *
 393:spi_via_usi_driver.c **** 
 394:spi_via_usi_driver.c ****  *  Use this function like you would write to the SPDR register in the native SPI module.
 395:spi_via_usi_driver.c **** 
 396:spi_via_usi_driver.c ****  *  Calling this function in master mode starts a transfer, while in slave mode, a
 397:spi_via_usi_driver.c **** 
 398:spi_via_usi_driver.c ****  *  byte will be prepared for the next transfer initiated by the master device.
 399:spi_via_usi_driver.c **** 
 400:spi_via_usi_driver.c ****  *  If a transfer is in progress, this function will set the write collision flag
 401:spi_via_usi_driver.c **** 
 402:spi_via_usi_driver.c ****  *  and return without altering the data registers.
 403:spi_via_usi_driver.c **** 
 404:spi_via_usi_driver.c ****  *
 405:spi_via_usi_driver.c **** 
 406:spi_via_usi_driver.c ****  *  \returns  0 if a write collision occurred, 1 otherwise.
 407:spi_via_usi_driver.c **** 
 408:spi_via_usi_driver.c ****  */
 409:spi_via_usi_driver.c **** 
 410:spi_via_usi_driver.c **** char spiX_put( unsigned char val )
 411:spi_via_usi_driver.c **** 
 412:spi_via_usi_driver.c **** {
 202               		.loc 1 412 0
 203               		.cfi_startproc
 204               	.LVL4:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 413:spi_via_usi_driver.c **** 
 414:spi_via_usi_driver.c **** 	// Check if transmission in progress,
 415:spi_via_usi_driver.c **** 
 416:spi_via_usi_driver.c **** 	// i.e. USI counter unequal to zero.
 417:spi_via_usi_driver.c **** 
 418:spi_via_usi_driver.c **** 	if( (USISR & 0x0F) != 0 ) {
 209               		.loc 1 418 0
 210 00d0 9EB1      		in r25,0xe
 211 00d2 9F70      		andi r25,lo8(15)
 212 00d4 01F0      		breq .L10
 419:spi_via_usi_driver.c **** 
 420:spi_via_usi_driver.c **** 		// Indicate write collision and return.
 421:spi_via_usi_driver.c **** 
 422:spi_via_usi_driver.c **** 		spiX_status.writeCollision = 1;
 213               		.loc 1 422 0
 214 00d6 8091 0000 		lds r24,spiX_status
 215               	.LVL5:
 216 00da 8460      		ori r24,lo8(1<<2)
 217 00dc 8093 0000 		sts spiX_status,r24
 423:spi_via_usi_driver.c **** 
 424:spi_via_usi_driver.c **** 		return 0;
 218               		.loc 1 424 0
 219 00e0 80E0      		ldi r24,0
 220 00e2 0895      		ret
 221               	.LVL6:
 222               	.L10:
 223               	.LBB14:
 224               	.LBB15:
 425:spi_via_usi_driver.c **** 
 426:spi_via_usi_driver.c **** 	}
 427:spi_via_usi_driver.c **** 
 428:spi_via_usi_driver.c **** 	// Reinit flags.
 429:spi_via_usi_driver.c **** 
 430:spi_via_usi_driver.c **** 	spiX_status.transferComplete = 0;
 225               		.loc 1 430 0
 226 00e4 9091 0000 		lds r25,spiX_status
 227 00e8 9D7F      		andi r25,lo8(~(1<<1))
 228 00ea 9093 0000 		sts spiX_status,r25
 431:spi_via_usi_driver.c **** 
 432:spi_via_usi_driver.c **** 	spiX_status.writeCollision = 0;
 229               		.loc 1 432 0
 230 00ee 9091 0000 		lds r25,spiX_status
 231 00f2 9B7F      		andi r25,lo8(~(1<<2))
 232 00f4 9093 0000 		sts spiX_status,r25
 433:spi_via_usi_driver.c **** 
 434:spi_via_usi_driver.c **** 
 435:spi_via_usi_driver.c **** 
 436:spi_via_usi_driver.c **** 	// Put data in USI data register.
 437:spi_via_usi_driver.c **** 
 438:spi_via_usi_driver.c **** 	USIDR = val;
 233               		.loc 1 438 0
 234 00f8 8FB9      		out 0xf,r24
 439:spi_via_usi_driver.c **** 
 440:spi_via_usi_driver.c **** 	
 441:spi_via_usi_driver.c **** 
 442:spi_via_usi_driver.c **** 	// Master should now enable compare match interrupts.
 443:spi_via_usi_driver.c **** 
 444:spi_via_usi_driver.c **** 	if( spiX_status.masterMode == 1 ) {
 235               		.loc 1 444 0
 236 00fa 8091 0000 		lds r24,spiX_status
 237               	.LVL7:
 238 00fe 80FF      		sbrs r24,0
 239 0100 00C0      		rjmp .L12
 445:spi_via_usi_driver.c **** 
 446:spi_via_usi_driver.c **** 		TIFR0 |= (1<<OCF0A);   // Clear compare match flag.
 240               		.loc 1 446 0
 241 0102 88B7      		in r24,0x38
 242 0104 8260      		ori r24,lo8(2)
 243 0106 88BF      		out 0x38,r24
 447:spi_via_usi_driver.c **** 
 448:spi_via_usi_driver.c **** 		TIMSK0 |= (1<<OCIE0A); // Enable compare match interrupt.
 244               		.loc 1 448 0
 245 0108 89B7      		in r24,0x39
 246 010a 8260      		ori r24,lo8(2)
 247 010c 89BF      		out 0x39,r24
 248               	.L12:
 449:spi_via_usi_driver.c **** 
 450:spi_via_usi_driver.c **** 	}
 451:spi_via_usi_driver.c **** 
 452:spi_via_usi_driver.c **** 
 453:spi_via_usi_driver.c **** 
 454:spi_via_usi_driver.c **** 	if( spiX_status.writeCollision == 0 ) return 1;
 249               		.loc 1 454 0
 250 010e 8091 0000 		lds r24,spiX_status
 251 0112 82FB      		bst r24,2
 252 0114 8827      		clr r24
 253 0116 80F9      		bld r24,0
 254 0118 91E0      		ldi r25,lo8(1)
 255 011a 8927      		eor r24,r25
 256               	.LBE15:
 257               	.LBE14:
 455:spi_via_usi_driver.c **** 
 456:spi_via_usi_driver.c **** 	return 0;
 457:spi_via_usi_driver.c **** 
 458:spi_via_usi_driver.c **** }
 258               		.loc 1 458 0
 259 011c 0895      		ret
 260               		.cfi_endproc
 261               	.LFE5:
 263               	.global	spiX_get
 265               	spiX_get:
 266               	.LFB6:
 459:spi_via_usi_driver.c **** 
 460:spi_via_usi_driver.c **** 
 461:spi_via_usi_driver.c **** 
 462:spi_via_usi_driver.c **** 
 463:spi_via_usi_driver.c **** 
 464:spi_via_usi_driver.c **** 
 465:spi_via_usi_driver.c **** 
 466:spi_via_usi_driver.c **** /*! \brief  Get one byte from bus.
 467:spi_via_usi_driver.c **** 
 468:spi_via_usi_driver.c ****  *
 469:spi_via_usi_driver.c **** 
 470:spi_via_usi_driver.c ****  *  This function only returns the previous stored USIDR value.
 471:spi_via_usi_driver.c **** 
 472:spi_via_usi_driver.c ****  *  The transfer complete flag is not checked. Use this function
 473:spi_via_usi_driver.c **** 
 474:spi_via_usi_driver.c ****  *  like you would read from the SPDR register in the native SPI module.
 475:spi_via_usi_driver.c **** 
 476:spi_via_usi_driver.c ****  */
 477:spi_via_usi_driver.c **** 
 478:spi_via_usi_driver.c **** unsigned char spiX_get(void)
 479:spi_via_usi_driver.c **** 
 480:spi_via_usi_driver.c **** {
 267               		.loc 1 480 0
 268               		.cfi_startproc
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 271               	/* stack size = 0 */
 272               	.L__stack_usage = 0
 481:spi_via_usi_driver.c **** 
 482:spi_via_usi_driver.c **** 	return storedUSIDR;
 483:spi_via_usi_driver.c **** 
 484:spi_via_usi_driver.c **** }
 273               		.loc 1 484 0
 274 011e 8091 0000 		lds r24,storedUSIDR
 275 0122 0895      		ret
 276               		.cfi_endproc
 277               	.LFE6:
 279               	.global	spiX_wait
 281               	spiX_wait:
 282               	.LFB7:
 485:spi_via_usi_driver.c **** 
 486:spi_via_usi_driver.c **** 
 487:spi_via_usi_driver.c **** 
 488:spi_via_usi_driver.c **** 
 489:spi_via_usi_driver.c **** 
 490:spi_via_usi_driver.c **** 
 491:spi_via_usi_driver.c **** 
 492:spi_via_usi_driver.c **** /*! \brief  Wait for transfer to complete.
 493:spi_via_usi_driver.c **** 
 494:spi_via_usi_driver.c ****  *
 495:spi_via_usi_driver.c **** 
 496:spi_via_usi_driver.c ****  *  This function waits until the transfer complete flag is set.
 497:spi_via_usi_driver.c **** 
 498:spi_via_usi_driver.c ****  *  Use this function like you would wait for the native SPI interrupt flag.
 499:spi_via_usi_driver.c **** 
 500:spi_via_usi_driver.c ****  */
 501:spi_via_usi_driver.c **** 
 502:spi_via_usi_driver.c **** void spiX_wait(void)
 503:spi_via_usi_driver.c **** 
 504:spi_via_usi_driver.c **** {
 283               		.loc 1 504 0
 284               		.cfi_startproc
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287               	/* stack size = 0 */
 288               	.L__stack_usage = 0
 289               	.L18:
 505:spi_via_usi_driver.c **** 
 506:spi_via_usi_driver.c **** 	do {} while( spiX_status.transferComplete == 0 );
 290               		.loc 1 506 0 discriminator 1
 291 0124 8091 0000 		lds r24,spiX_status
 292 0128 81FF      		sbrs r24,1
 293 012a 00C0      		rjmp .L18
 294               	/* epilogue start */
 507:spi_via_usi_driver.c **** 
 508:spi_via_usi_driver.c **** }
 295               		.loc 1 508 0
 296 012c 0895      		ret
 297               		.cfi_endproc
 298               	.LFE7:
 300               	.global	setupIO
 302               	setupIO:
 303               	.LFB10:
 304               		.file 2 "ambient-attx4.c"
   1:ambient-attx4.c **** // Copyright 2014 Technical Machine, Inc. See the COPYRIGHT
   2:ambient-attx4.c **** // file at the top-level directory of this distribution.
   3:ambient-attx4.c **** //
   4:ambient-attx4.c **** // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
   5:ambient-attx4.c **** // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
   6:ambient-attx4.c **** // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
   7:ambient-attx4.c **** // option. This file may not be copied, modified, or distributed
   8:ambient-attx4.c **** // except according to those terms.
   9:ambient-attx4.c **** 
  10:ambient-attx4.c **** #include "ambient-attx4.h"
  11:ambient-attx4.c **** 
  12:ambient-attx4.c **** // Iterater
  13:ambient-attx4.c **** volatile int counter = 0;
  14:ambient-attx4.c **** 
  15:ambient-attx4.c **** // Light trigger to be hit
  16:ambient-attx4.c **** volatile uint16_t lightTrigger = 0x00;
  17:ambient-attx4.c **** // Value read on trigger hit
  18:ambient-attx4.c **** volatile uint16_t lightTriggerReadVal = 0x00;
  19:ambient-attx4.c **** 
  20:ambient-attx4.c **** // Loudness trigger to be hit
  21:ambient-attx4.c **** volatile uint16_t soundTrigger = 0x00;
  22:ambient-attx4.c **** // Value read on trigger hit
  23:ambient-attx4.c **** volatile uint16_t soundTriggerReadVal = 0x00;
  24:ambient-attx4.c **** 
  25:ambient-attx4.c **** // Program Flash Checksum
  26:ambient-attx4.c **** volatile unsigned short checksum = 0xffff;
  27:ambient-attx4.c **** 
  28:ambient-attx4.c **** // A buffer and buffer indexer for each source
  29:ambient-attx4.c **** volatile DataBuffer LightBuffer;
  30:ambient-attx4.c **** volatile DataBuffer SoundBuffer;
  31:ambient-attx4.c **** 
  32:ambient-attx4.c **** void setup(void);
  33:ambient-attx4.c **** void setupIO(void);
  34:ambient-attx4.c **** void enableSPI(void);
  35:ambient-attx4.c **** void setupTimer(void);
  36:ambient-attx4.c **** void prepareADC(void);
  37:ambient-attx4.c **** uint16_t analogRead(char pin);
  38:ambient-attx4.c **** volatile DataBuffer bufferForCommand(uint8_t command);
  39:ambient-attx4.c **** 
  40:ambient-attx4.c **** 
  41:ambient-attx4.c **** extern void _exit();
  42:ambient-attx4.c **** 
  43:ambient-attx4.c **** int main(void) {
  44:ambient-attx4.c ****   checksum = crc16( (unsigned short) _exit << 1 );
  45:ambient-attx4.c **** 
  46:ambient-attx4.c ****   setup();
  47:ambient-attx4.c **** 
  48:ambient-attx4.c ****   while (1){};
  49:ambient-attx4.c **** 
  50:ambient-attx4.c ****   return 0;
  51:ambient-attx4.c **** 
  52:ambient-attx4.c **** }
  53:ambient-attx4.c **** 
  54:ambient-attx4.c **** void setup(void) {
  55:ambient-attx4.c **** 
  56:ambient-attx4.c ****   // Turn off interrupts
  57:ambient-attx4.c ****   cli();
  58:ambient-attx4.c **** 
  59:ambient-attx4.c ****   // Reset buffer locations
  60:ambient-attx4.c ****   LightBuffer.bufferLocation = 0;
  61:ambient-attx4.c ****   SoundBuffer.bufferLocation = 0;
  62:ambient-attx4.c **** 
  63:ambient-attx4.c ****   setupIO();
  64:ambient-attx4.c **** 
  65:ambient-attx4.c ****   prepareADC();
  66:ambient-attx4.c **** 
  67:ambient-attx4.c ****   enableSPI();
  68:ambient-attx4.c **** 
  69:ambient-attx4.c ****   setupTimer();
  70:ambient-attx4.c **** 
  71:ambient-attx4.c ****   // Unleash the interrupts!
  72:ambient-attx4.c ****   sei();
  73:ambient-attx4.c **** 
  74:ambient-attx4.c **** }
  75:ambient-attx4.c **** 
  76:ambient-attx4.c **** void setupIO(void) {
 305               		.loc 2 76 0
 306               		.cfi_startproc
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
  77:ambient-attx4.c ****   // Make the "decibel" pin an input
  78:ambient-attx4.c ****   cbi(DDRA, SOUND_PIN);
 311               		.loc 2 78 0
 312 012e D198      		cbi 0x1a,1
  79:ambient-attx4.c **** 
  80:ambient-attx4.c ****   // Make the ambient light as input
  81:ambient-attx4.c ****   cbi(DDRA, LIGHT_PIN);
 313               		.loc 2 81 0
 314 0130 D398      		cbi 0x1a,3
  82:ambient-attx4.c **** 
  83:ambient-attx4.c ****   // Make the Interrupt pin an output
  84:ambient-attx4.c ****   sbi(DDRB, IRQ_PIN);
 315               		.loc 2 84 0
 316 0132 B99A      		sbi 0x17,1
  85:ambient-attx4.c **** 
  86:ambient-attx4.c ****   // Pull it low
  87:ambient-attx4.c ****   cbi(PORTB, IRQ_PIN);
 317               		.loc 2 87 0
 318 0134 C198      		cbi 0x18,1
  88:ambient-attx4.c **** 
  89:ambient-attx4.c ****   // Set MOSI as an input
  90:ambient-attx4.c ****   cbi(DDRA, MOSI);
 319               		.loc 2 90 0
 320 0136 D698      		cbi 0x1a,6
 321 0138 0895      		ret
 322               		.cfi_endproc
 323               	.LFE10:
 325               	.global	enableSPI
 327               	enableSPI:
 328               	.LFB11:
  91:ambient-attx4.c **** }
  92:ambient-attx4.c **** 
  93:ambient-attx4.c **** void enableSPI(void) {
 329               		.loc 2 93 0
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
  94:ambient-attx4.c ****   // configure: interrupt on INT0 pin falling edge
  95:ambient-attx4.c ****   MCUCR = (1<<ISC01);
 335               		.loc 2 95 0
 336 013a 82E0      		ldi r24,lo8(2)
 337 013c 85BF      		out 0x35,r24
  96:ambient-attx4.c **** 
  97:ambient-attx4.c ****   // enable interrupt
  98:ambient-attx4.c ****   sbi(GIMSK, INT0);
 338               		.loc 2 98 0
 339 013e 8BB7      		in r24,0x3b
 340 0140 8064      		ori r24,lo8(64)
 341 0142 8BBF      		out 0x3b,r24
  99:ambient-attx4.c **** 
 100:ambient-attx4.c ****   // Set CS as INPUT
 101:ambient-attx4.c ****   cbi(DDRB, CS_PIN);
 342               		.loc 2 101 0
 343 0144 BA98      		cbi 0x17,2
 102:ambient-attx4.c **** 
 103:ambient-attx4.c ****   // Set up pull up to keep CS high
 104:ambient-attx4.c ****   sbi(PORTB, CS_PIN);
 344               		.loc 2 104 0
 345 0146 C29A      		sbi 0x18,2
 105:ambient-attx4.c **** 
 106:ambient-attx4.c ****   // disable spi counter overflow enable
 107:ambient-attx4.c ****   USICR&= ~(1<<USIOIE);
 346               		.loc 2 107 0
 347 0148 6E98      		cbi 0xd,6
 108:ambient-attx4.c ****   USICR&= ~(1<<USIWM0);
 348               		.loc 2 108 0
 349 014a 6C98      		cbi 0xd,4
 350 014c 0895      		ret
 351               		.cfi_endproc
 352               	.LFE11:
 354               	.global	setupTimer
 356               	setupTimer:
 357               	.LFB12:
 109:ambient-attx4.c **** }
 110:ambient-attx4.c **** 
 111:ambient-attx4.c **** void setupTimer(void) {
 358               		.loc 2 111 0
 359               		.cfi_startproc
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
 112:ambient-attx4.c ****   // Set clock divider to 8 (1MHz)
 113:ambient-attx4.c ****   sbi(TCCR1B, CS11);
 364               		.loc 2 113 0
 365 014e 8EB5      		in r24,0x2e
 366 0150 8260      		ori r24,lo8(2)
 367 0152 8EBD      		out 0x2e,r24
 114:ambient-attx4.c **** 
 115:ambient-attx4.c ****   // Set the counter to CTC (clear on match)
 116:ambient-attx4.c ****   sbi(TCCR1B, WGM12);
 368               		.loc 2 116 0
 369 0154 8EB5      		in r24,0x2e
 370 0156 8860      		ori r24,lo8(8)
 371 0158 8EBD      		out 0x2e,r24
 117:ambient-attx4.c **** 
 118:ambient-attx4.c ****   // Set frequency to 5kHz
 119:ambient-attx4.c ****   // (8000000/8/200) Hz
 120:ambient-attx4.c ****   OCR1A = 200;
 372               		.loc 2 120 0
 373 015a 88EC      		ldi r24,lo8(-56)
 374 015c 90E0      		ldi r25,0
 375 015e 9BBD      		out 0x2a+1,r25
 376 0160 8ABD      		out 0x2a,r24
 121:ambient-attx4.c **** 
 122:ambient-attx4.c ****   // Allow interrupts on comp a
 123:ambient-attx4.c ****   sbi(TIMSK1, OCIE1A);
 377               		.loc 2 123 0
 378 0162 619A      		sbi 0xc,1
 379 0164 0895      		ret
 380               		.cfi_endproc
 381               	.LFE12:
 383               	.global	prepareADC
 385               	prepareADC:
 386               	.LFB13:
 124:ambient-attx4.c **** }
 125:ambient-attx4.c **** 
 126:ambient-attx4.c **** void prepareADC(void) {
 387               		.loc 2 126 0
 388               		.cfi_startproc
 389               	/* prologue: function */
 390               	/* frame size = 0 */
 391               	/* stack size = 0 */
 392               	.L__stack_usage = 0
 127:ambient-attx4.c **** 
 128:ambient-attx4.c ****   // Make sure the power reduction register isn't set
 129:ambient-attx4.c ****   cbi(PRR, PRADC);
 393               		.loc 2 129 0
 394 0166 0098      		cbi 0,0
 130:ambient-attx4.c **** 
 131:ambient-attx4.c ****   // Enable ADC by writing ADEN in ADSCRA
 132:ambient-attx4.c ****   sbi(ADCSRA, ADEN);
 395               		.loc 2 132 0
 396 0168 379A      		sbi 0x6,7
 133:ambient-attx4.c **** 
 134:ambient-attx4.c ****   // Set up ADC clock prescalar to 64 (125kHz) by writing ADPS bits of ADSCRA
 135:ambient-attx4.c ****   ADCSRA |= 6;
 397               		.loc 2 135 0
 398 016a 86B1      		in r24,0x6
 399 016c 8660      		ori r24,lo8(6)
 400 016e 86B9      		out 0x6,r24
 136:ambient-attx4.c **** 
 137:ambient-attx4.c ****   // Set reference voltage to AREF by writing to the ADMUX register
 138:ambient-attx4.c ****   ADMUX = 0;
 401               		.loc 2 138 0
 402 0170 17B8      		out 0x7,__zero_reg__
 139:ambient-attx4.c ****   cbi(ADMUX, REFS1);
 403               		.loc 2 139 0
 404 0172 3F98      		cbi 0x7,7
 140:ambient-attx4.c ****   sbi(ADMUX, REFS0);
 405               		.loc 2 140 0
 406 0174 3E9A      		sbi 0x7,6
 407 0176 0895      		ret
 408               		.cfi_endproc
 409               	.LFE13:
 411               	.global	setup
 413               	setup:
 414               	.LFB9:
  54:ambient-attx4.c **** void setup(void) {
 415               		.loc 2 54 0
 416               		.cfi_startproc
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 0 */
 420               	.L__stack_usage = 0
  57:ambient-attx4.c ****   cli();
 421               		.loc 2 57 0
 422               	/* #APP */
 423               	 ;  57 "ambient-attx4.c" 1
 424 0178 F894      		cli
 425               	 ;  0 "" 2
  60:ambient-attx4.c ****   LightBuffer.bufferLocation = 0;
 426               		.loc 2 60 0
 427               	/* #NOAPP */
 428 017a 1092 0000 		sts LightBuffer+20,__zero_reg__
  61:ambient-attx4.c ****   SoundBuffer.bufferLocation = 0;
 429               		.loc 2 61 0
 430 017e 1092 0000 		sts SoundBuffer+20,__zero_reg__
  63:ambient-attx4.c ****   setupIO();
 431               		.loc 2 63 0
 432 0182 00D0      		rcall setupIO
 433               	.LVL8:
  65:ambient-attx4.c ****   prepareADC();
 434               		.loc 2 65 0
 435 0184 00D0      		rcall prepareADC
 436               	.LVL9:
  67:ambient-attx4.c ****   enableSPI();
 437               		.loc 2 67 0
 438 0186 00D0      		rcall enableSPI
 439               	.LVL10:
  69:ambient-attx4.c ****   setupTimer();
 440               		.loc 2 69 0
 441 0188 00D0      		rcall setupTimer
 442               	.LVL11:
  72:ambient-attx4.c ****   sei();
 443               		.loc 2 72 0
 444               	/* #APP */
 445               	 ;  72 "ambient-attx4.c" 1
 446 018a 7894      		sei
 447               	 ;  0 "" 2
 448               	/* #NOAPP */
 449 018c 0895      		ret
 450               		.cfi_endproc
 451               	.LFE9:
 453               	.global	analogRead
 455               	analogRead:
 456               	.LFB14:
 141:ambient-attx4.c **** }
 142:ambient-attx4.c **** 
 143:ambient-attx4.c **** uint16_t analogRead(char pin) {
 457               		.loc 2 143 0
 458               		.cfi_startproc
 459               	.LVL12:
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 0 */
 463               	.L__stack_usage = 0
 144:ambient-attx4.c **** 
 145:ambient-attx4.c ****   uint16_t value;
 146:ambient-attx4.c **** 
 147:ambient-attx4.c ****   // Clear lowest five bits
 148:ambient-attx4.c ****   ADMUX &= 0b11100000;
 464               		.loc 2 148 0
 465 018e 97B1      		in r25,0x7
 466 0190 907E      		andi r25,lo8(-32)
 467 0192 97B9      		out 0x7,r25
 149:ambient-attx4.c **** 
 150:ambient-attx4.c ****   // Set five bits with pin
 151:ambient-attx4.c ****   ADMUX |= (pin & 0b00011111);
 468               		.loc 2 151 0
 469 0194 97B1      		in r25,0x7
 470 0196 8F71      		andi r24,lo8(31)
 471               	.LVL13:
 472 0198 892B      		or r24,r25
 473 019a 87B9      		out 0x7,r24
 152:ambient-attx4.c **** 
 153:ambient-attx4.c ****   // Start the conversion
 154:ambient-attx4.c ****   sbi(ADCSRA, ADSC);
 474               		.loc 2 154 0
 475 019c 369A      		sbi 0x6,6
 476               	.L29:
 155:ambient-attx4.c **** 
 156:ambient-attx4.c ****   // Wait for the conversion to finish
 157:ambient-attx4.c ****   while((ADCSRA & (1<<ADSC)) != 0);
 477               		.loc 2 157 0 discriminator 1
 478 019e 3699      		sbic 0x6,6
 479 01a0 00C0      		rjmp .L29
 158:ambient-attx4.c **** 
 159:ambient-attx4.c ****   value = ADCL;
 480               		.loc 2 159 0
 481 01a2 24B1      		in r18,0x4
 482               	.LVL14:
 160:ambient-attx4.c **** 
 161:ambient-attx4.c ****   value += (ADCH << 8);
 483               		.loc 2 161 0
 484 01a4 35B1      		in r19,0x5
 485               	.LVL15:
 486 01a6 932F      		mov r25,r19
 487 01a8 80E0      		ldi r24,0
 488 01aa AC01      		movw r20,r24
 489 01ac 420F      		add r20,r18
 490 01ae 511D      		adc r21,__zero_reg__
 162:ambient-attx4.c **** 
 163:ambient-attx4.c ****   // Return the 10 bit result
 164:ambient-attx4.c ****   return value;
 165:ambient-attx4.c **** }
 491               		.loc 2 165 0
 492 01b0 CA01      		movw r24,r20
 493 01b2 0895      		ret
 494               		.cfi_endproc
 495               	.LFE14:
 497               	.global	bufferForCommand
 499               	bufferForCommand:
 500               	.LFB15:
 166:ambient-attx4.c **** 
 167:ambient-attx4.c **** volatile DataBuffer bufferForCommand(uint8_t command) {
 501               		.loc 2 167 0
 502               		.cfi_startproc
 503               	.LVL16:
 504               	/* prologue: function */
 505               	/* frame size = 0 */
 506               	/* stack size = 0 */
 507               	.L__stack_usage = 0
 168:ambient-attx4.c **** 
 169:ambient-attx4.c ****   if (command == LIGHT_CMD)
 170:ambient-attx4.c ****   {
 171:ambient-attx4.c ****     return LightBuffer;
 508               		.loc 2 171 0
 509 01b4 25E1      		ldi r18,lo8(21)
 169:ambient-attx4.c ****   if (command == LIGHT_CMD)
 510               		.loc 2 169 0
 511 01b6 6230      		cpi r22,lo8(2)
 512 01b8 01F4      		brne .L32
 513               		.loc 2 171 0
 514 01ba E0E0      		ldi r30,lo8(LightBuffer)
 515 01bc F0E0      		ldi r31,hi8(LightBuffer)
 516 01be 00C0      		rjmp .L34
 517               	.L32:
 172:ambient-attx4.c ****   }
 173:ambient-attx4.c ****   else
 174:ambient-attx4.c ****   {
 175:ambient-attx4.c ****     return SoundBuffer;
 518               		.loc 2 175 0
 519 01c0 E0E0      		ldi r30,lo8(SoundBuffer)
 520 01c2 F0E0      		ldi r31,hi8(SoundBuffer)
 521               	.L34:
 522 01c4 DC01      		movw r26,r24
 523               		0:
 524 01c6 0190      		ld r0,Z+
 525 01c8 0D92      		st X+,r0
 526 01ca 2A95      		dec r18
 527 01cc 01F4      		brne 0b
 176:ambient-attx4.c ****   }
 177:ambient-attx4.c **** }
 528               		.loc 2 177 0
 529 01ce 0895      		ret
 530               		.cfi_endproc
 531               	.LFE15:
 533               	.global	triggerValueForCommand
 535               	triggerValueForCommand:
 536               	.LFB16:
 178:ambient-attx4.c **** 
 179:ambient-attx4.c **** volatile uint16_t *triggerValueForCommand(uint8_t command) {
 537               		.loc 2 179 0
 538               		.cfi_startproc
 539               	.LVL17:
 540               	/* prologue: function */
 541               	/* frame size = 0 */
 542               	/* stack size = 0 */
 543               	.L__stack_usage = 0
 180:ambient-attx4.c ****   if (command == LIGHT_TRIGGER_CMD) {
 544               		.loc 2 180 0
 545 01d0 8430      		cpi r24,lo8(4)
 546 01d2 01F4      		brne .L37
 181:ambient-attx4.c ****     return &lightTrigger;
 547               		.loc 2 181 0
 548 01d4 20E0      		ldi r18,lo8(lightTrigger)
 549 01d6 30E0      		ldi r19,hi8(lightTrigger)
 550 01d8 00C0      		rjmp .L36
 551               	.L37:
 182:ambient-attx4.c ****   }
 183:ambient-attx4.c ****   else {
 184:ambient-attx4.c ****     return &soundTrigger;
 552               		.loc 2 184 0
 553 01da 20E0      		ldi r18,lo8(soundTrigger)
 554 01dc 30E0      		ldi r19,hi8(soundTrigger)
 555               	.L36:
 185:ambient-attx4.c ****   }
 186:ambient-attx4.c **** }
 556               		.loc 2 186 0
 557 01de C901      		movw r24,r18
 558               	.LVL18:
 559 01e0 0895      		ret
 560               		.cfi_endproc
 561               	.LFE16:
 563               	.global	__vector_6
 565               	__vector_6:
 566               	.LFB17:
 187:ambient-attx4.c **** 
 188:ambient-attx4.c **** ISR(TIM1_COMPA_vect) {
 567               		.loc 2 188 0
 568               		.cfi_startproc
 569 01e2 1F92      		push r1
 570               	.LCFI5:
 571               		.cfi_def_cfa_offset 3
 572               		.cfi_offset 1, -2
 573 01e4 0F92      		push r0
 574               	.LCFI6:
 575               		.cfi_def_cfa_offset 4
 576               		.cfi_offset 0, -3
 577 01e6 0FB6      		in r0,__SREG__
 578 01e8 0F92      		push r0
 579 01ea 1124      		clr __zero_reg__
 580 01ec 1F93      		push r17
 581               	.LCFI7:
 582               		.cfi_def_cfa_offset 5
 583               		.cfi_offset 17, -4
 584 01ee 2F93      		push r18
 585               	.LCFI8:
 586               		.cfi_def_cfa_offset 6
 587               		.cfi_offset 18, -5
 588 01f0 3F93      		push r19
 589               	.LCFI9:
 590               		.cfi_def_cfa_offset 7
 591               		.cfi_offset 19, -6
 592 01f2 4F93      		push r20
 593               	.LCFI10:
 594               		.cfi_def_cfa_offset 8
 595               		.cfi_offset 20, -7
 596 01f4 5F93      		push r21
 597               	.LCFI11:
 598               		.cfi_def_cfa_offset 9
 599               		.cfi_offset 21, -8
 600 01f6 6F93      		push r22
 601               	.LCFI12:
 602               		.cfi_def_cfa_offset 10
 603               		.cfi_offset 22, -9
 604 01f8 7F93      		push r23
 605               	.LCFI13:
 606               		.cfi_def_cfa_offset 11
 607               		.cfi_offset 23, -10
 608 01fa 8F93      		push r24
 609               	.LCFI14:
 610               		.cfi_def_cfa_offset 12
 611               		.cfi_offset 24, -11
 612 01fc 9F93      		push r25
 613               	.LCFI15:
 614               		.cfi_def_cfa_offset 13
 615               		.cfi_offset 25, -12
 616 01fe AF93      		push r26
 617               	.LCFI16:
 618               		.cfi_def_cfa_offset 14
 619               		.cfi_offset 26, -13
 620 0200 BF93      		push r27
 621               	.LCFI17:
 622               		.cfi_def_cfa_offset 15
 623               		.cfi_offset 27, -14
 624 0202 CF93      		push r28
 625               	.LCFI18:
 626               		.cfi_def_cfa_offset 16
 627               		.cfi_offset 28, -15
 628 0204 DF93      		push r29
 629               	.LCFI19:
 630               		.cfi_def_cfa_offset 17
 631               		.cfi_offset 29, -16
 632 0206 EF93      		push r30
 633               	.LCFI20:
 634               		.cfi_def_cfa_offset 18
 635               		.cfi_offset 30, -17
 636 0208 FF93      		push r31
 637               	.LCFI21:
 638               		.cfi_def_cfa_offset 19
 639               		.cfi_offset 31, -18
 640               	/* prologue: Signal */
 641               	/* frame size = 0 */
 642               	/* stack size = 18 */
 643               	.L__stack_usage = 18
 189:ambient-attx4.c **** 
 190:ambient-attx4.c ****   LightBuffer.buffer[LightBuffer.bufferLocation++] = analogRead(LIGHT_PIN);
 644               		.loc 2 190 0
 645 020a 1091 0000 		lds r17,LightBuffer+20
 646 020e C12F      		mov r28,r17
 647 0210 D0E0      		ldi r29,0
 648 0212 83E0      		ldi r24,lo8(3)
 649 0214 00D0      		rcall analogRead
 650               	.LVL19:
 651 0216 FE01      		movw r30,r28
 652 0218 EE0F      		lsl r30
 653 021a FF1F      		rol r31
 654 021c E050      		subi r30,lo8(-(LightBuffer))
 655 021e F040      		sbci r31,hi8(-(LightBuffer))
 656 0220 9183      		std Z+1,r25
 657 0222 8083      		st Z,r24
 658 0224 1F5F      		subi r17,lo8(-(1))
 659 0226 1093 0000 		sts LightBuffer+20,r17
 191:ambient-attx4.c **** 
 192:ambient-attx4.c ****   // If a light trigger has been set and the level is hit
 193:ambient-attx4.c ****   if (lightTrigger != 0 && LightBuffer.buffer[LightBuffer.bufferLocation - 1] >= lightTrigger) {
 660               		.loc 2 193 0
 661 022a 8091 0000 		lds r24,lightTrigger
 662 022e 9091 0000 		lds r25,lightTrigger+1
 663 0232 892B      		or r24,r25
 664 0234 01F0      		breq .L39
 665               		.loc 2 193 0 is_stmt 0 discriminator 1
 666 0236 E091 0000 		lds r30,LightBuffer+20
 667 023a F0E0      		ldi r31,0
 668 023c EE0F      		lsl r30
 669 023e FF1F      		rol r31
 670 0240 E050      		subi r30,lo8(-(LightBuffer-2))
 671 0242 F040      		sbci r31,hi8(-(LightBuffer-2))
 672 0244 2081      		ld r18,Z
 673 0246 3181      		ldd r19,Z+1
 674 0248 8091 0000 		lds r24,lightTrigger
 675 024c 9091 0000 		lds r25,lightTrigger+1
 676 0250 2817      		cp r18,r24
 677 0252 3907      		cpc r19,r25
 678 0254 00F0      		brlo .L39
 194:ambient-attx4.c **** 
 195:ambient-attx4.c ****     // Set the read value
 196:ambient-attx4.c ****     lightTriggerReadVal = LightBuffer.buffer[LightBuffer.bufferLocation - 1];
 679               		.loc 2 196 0 is_stmt 1
 680 0256 E091 0000 		lds r30,LightBuffer+20
 681 025a F0E0      		ldi r31,0
 682 025c EE0F      		lsl r30
 683 025e FF1F      		rol r31
 684 0260 E050      		subi r30,lo8(-(LightBuffer-2))
 685 0262 F040      		sbci r31,hi8(-(LightBuffer-2))
 686 0264 8081      		ld r24,Z
 687 0266 9181      		ldd r25,Z+1
 688 0268 9093 0000 		sts lightTriggerReadVal+1,r25
 689 026c 8093 0000 		sts lightTriggerReadVal,r24
 197:ambient-attx4.c **** 
 198:ambient-attx4.c ****     // Raise the interrupt pin
 199:ambient-attx4.c ****     sbi(PORTB, IRQ_PIN);
 690               		.loc 2 199 0
 691 0270 C19A      		sbi 0x18,1
 692               	.L39:
 200:ambient-attx4.c **** 
 201:ambient-attx4.c ****   }
 202:ambient-attx4.c **** 
 203:ambient-attx4.c ****   if (LightBuffer.bufferLocation == BUF_SIZE) {
 693               		.loc 2 203 0
 694 0272 8091 0000 		lds r24,LightBuffer+20
 695 0276 8A30      		cpi r24,lo8(10)
 696 0278 01F4      		brne .L40
 204:ambient-attx4.c ****     LightBuffer.bufferLocation = 0;
 697               		.loc 2 204 0
 698 027a 1092 0000 		sts LightBuffer+20,__zero_reg__
 699               	.L40:
 205:ambient-attx4.c ****   }
 206:ambient-attx4.c **** 
 207:ambient-attx4.c ****   SoundBuffer.buffer[SoundBuffer.bufferLocation++] = analogRead(SOUND_PIN);
 700               		.loc 2 207 0
 701 027e 1091 0000 		lds r17,SoundBuffer+20
 702 0282 C12F      		mov r28,r17
 703 0284 D0E0      		ldi r29,0
 704 0286 81E0      		ldi r24,lo8(1)
 705 0288 00D0      		rcall analogRead
 706               	.LVL20:
 707 028a FE01      		movw r30,r28
 708 028c EE0F      		lsl r30
 709 028e FF1F      		rol r31
 710 0290 E050      		subi r30,lo8(-(SoundBuffer))
 711 0292 F040      		sbci r31,hi8(-(SoundBuffer))
 712 0294 9183      		std Z+1,r25
 713 0296 8083      		st Z,r24
 714 0298 1F5F      		subi r17,lo8(-(1))
 715 029a 1093 0000 		sts SoundBuffer+20,r17
 208:ambient-attx4.c **** 
 209:ambient-attx4.c ****     // If a loudness trigger has been set and the level is hit
 210:ambient-attx4.c ****   if (soundTrigger != 0 && SoundBuffer.buffer[SoundBuffer.bufferLocation - 1] >= soundTrigger) {
 716               		.loc 2 210 0
 717 029e 8091 0000 		lds r24,soundTrigger
 718 02a2 9091 0000 		lds r25,soundTrigger+1
 719 02a6 892B      		or r24,r25
 720 02a8 01F0      		breq .L41
 721               		.loc 2 210 0 is_stmt 0 discriminator 1
 722 02aa E091 0000 		lds r30,SoundBuffer+20
 723 02ae F0E0      		ldi r31,0
 724 02b0 EE0F      		lsl r30
 725 02b2 FF1F      		rol r31
 726 02b4 E050      		subi r30,lo8(-(SoundBuffer-2))
 727 02b6 F040      		sbci r31,hi8(-(SoundBuffer-2))
 728 02b8 2081      		ld r18,Z
 729 02ba 3181      		ldd r19,Z+1
 730 02bc 8091 0000 		lds r24,soundTrigger
 731 02c0 9091 0000 		lds r25,soundTrigger+1
 732 02c4 2817      		cp r18,r24
 733 02c6 3907      		cpc r19,r25
 734 02c8 00F0      		brlo .L41
 211:ambient-attx4.c **** 
 212:ambient-attx4.c ****     // Set the read value
 213:ambient-attx4.c ****     soundTriggerReadVal = SoundBuffer.buffer[SoundBuffer.bufferLocation - 1];
 735               		.loc 2 213 0 is_stmt 1
 736 02ca E091 0000 		lds r30,SoundBuffer+20
 737 02ce F0E0      		ldi r31,0
 738 02d0 EE0F      		lsl r30
 739 02d2 FF1F      		rol r31
 740 02d4 E050      		subi r30,lo8(-(SoundBuffer-2))
 741 02d6 F040      		sbci r31,hi8(-(SoundBuffer-2))
 742 02d8 8081      		ld r24,Z
 743 02da 9181      		ldd r25,Z+1
 744 02dc 9093 0000 		sts soundTriggerReadVal+1,r25
 745 02e0 8093 0000 		sts soundTriggerReadVal,r24
 214:ambient-attx4.c **** 
 215:ambient-attx4.c ****     // Raise the interrupt pin
 216:ambient-attx4.c ****     sbi(PORTB, IRQ_PIN);
 746               		.loc 2 216 0
 747 02e4 C19A      		sbi 0x18,1
 748               	.L41:
 217:ambient-attx4.c ****   }
 218:ambient-attx4.c **** 
 219:ambient-attx4.c ****   if (SoundBuffer.bufferLocation == BUF_SIZE) {
 749               		.loc 2 219 0
 750 02e6 8091 0000 		lds r24,SoundBuffer+20
 751 02ea 8A30      		cpi r24,lo8(10)
 752 02ec 01F4      		brne .L38
 220:ambient-attx4.c ****     SoundBuffer.bufferLocation = 0;
 753               		.loc 2 220 0
 754 02ee 1092 0000 		sts SoundBuffer+20,__zero_reg__
 755               	.L38:
 756               	/* epilogue start */
 221:ambient-attx4.c ****   }
 222:ambient-attx4.c **** }
 757               		.loc 2 222 0
 758 02f2 FF91      		pop r31
 759 02f4 EF91      		pop r30
 760 02f6 DF91      		pop r29
 761 02f8 CF91      		pop r28
 762 02fa BF91      		pop r27
 763 02fc AF91      		pop r26
 764 02fe 9F91      		pop r25
 765 0300 8F91      		pop r24
 766 0302 7F91      		pop r23
 767 0304 6F91      		pop r22
 768 0306 5F91      		pop r21
 769 0308 4F91      		pop r20
 770 030a 3F91      		pop r19
 771 030c 2F91      		pop r18
 772 030e 1F91      		pop r17
 773 0310 0F90      		pop r0
 774 0312 0FBE      		out __SREG__,r0
 775 0314 0F90      		pop r0
 776 0316 1F90      		pop r1
 777 0318 1895      		reti
 778               		.cfi_endproc
 779               	.LFE17:
 781               	.global	__vector_1
 783               	__vector_1:
 784               	.LFB18:
 223:ambient-attx4.c **** 
 224:ambient-attx4.c **** ISR(INT0_vect){
 785               		.loc 2 224 0
 786               		.cfi_startproc
 787 031a 1F92      		push r1
 788               	.LCFI22:
 789               		.cfi_def_cfa_offset 3
 790               		.cfi_offset 1, -2
 791 031c 0F92      		push r0
 792               	.LCFI23:
 793               		.cfi_def_cfa_offset 4
 794               		.cfi_offset 0, -3
 795 031e 0FB6      		in r0,__SREG__
 796 0320 0F92      		push r0
 797 0322 1124      		clr __zero_reg__
 798 0324 DF92      		push r13
 799               	.LCFI24:
 800               		.cfi_def_cfa_offset 5
 801               		.cfi_offset 13, -4
 802 0326 EF92      		push r14
 803               	.LCFI25:
 804               		.cfi_def_cfa_offset 6
 805               		.cfi_offset 14, -5
 806 0328 FF92      		push r15
 807               	.LCFI26:
 808               		.cfi_def_cfa_offset 7
 809               		.cfi_offset 15, -6
 810 032a 0F93      		push r16
 811               	.LCFI27:
 812               		.cfi_def_cfa_offset 8
 813               		.cfi_offset 16, -7
 814 032c 1F93      		push r17
 815               	.LCFI28:
 816               		.cfi_def_cfa_offset 9
 817               		.cfi_offset 17, -8
 818 032e 2F93      		push r18
 819               	.LCFI29:
 820               		.cfi_def_cfa_offset 10
 821               		.cfi_offset 18, -9
 822 0330 3F93      		push r19
 823               	.LCFI30:
 824               		.cfi_def_cfa_offset 11
 825               		.cfi_offset 19, -10
 826 0332 4F93      		push r20
 827               	.LCFI31:
 828               		.cfi_def_cfa_offset 12
 829               		.cfi_offset 20, -11
 830 0334 5F93      		push r21
 831               	.LCFI32:
 832               		.cfi_def_cfa_offset 13
 833               		.cfi_offset 21, -12
 834 0336 6F93      		push r22
 835               	.LCFI33:
 836               		.cfi_def_cfa_offset 14
 837               		.cfi_offset 22, -13
 838 0338 7F93      		push r23
 839               	.LCFI34:
 840               		.cfi_def_cfa_offset 15
 841               		.cfi_offset 23, -14
 842 033a 8F93      		push r24
 843               	.LCFI35:
 844               		.cfi_def_cfa_offset 16
 845               		.cfi_offset 24, -15
 846 033c 9F93      		push r25
 847               	.LCFI36:
 848               		.cfi_def_cfa_offset 17
 849               		.cfi_offset 25, -16
 850 033e AF93      		push r26
 851               	.LCFI37:
 852               		.cfi_def_cfa_offset 18
 853               		.cfi_offset 26, -17
 854 0340 BF93      		push r27
 855               	.LCFI38:
 856               		.cfi_def_cfa_offset 19
 857               		.cfi_offset 27, -18
 858 0342 EF93      		push r30
 859               	.LCFI39:
 860               		.cfi_def_cfa_offset 20
 861               		.cfi_offset 30, -19
 862 0344 FF93      		push r31
 863               	.LCFI40:
 864               		.cfi_def_cfa_offset 21
 865               		.cfi_offset 31, -20
 866 0346 CF93      		push r28
 867               	.LCFI41:
 868               		.cfi_def_cfa_offset 22
 869               		.cfi_offset 28, -21
 870 0348 DF93      		push r29
 871               	.LCFI42:
 872               		.cfi_def_cfa_offset 23
 873               		.cfi_offset 29, -22
 874 034a CDB7      		in r28,__SP_L__
 875 034c DD27      		clr r29
 876               	.LCFI43:
 877               		.cfi_def_cfa_register 28
 878 034e C851      		subi r28,lo8(-(-24))
 879               	.LCFI44:
 880               		.cfi_def_cfa_offset 47
 881 0350 CDBF      		out __SP_L__,r28
 882               	/* prologue: Signal */
 883               	/* frame size = 24 */
 884               	/* stack size = 46 */
 885               	.L__stack_usage = 46
 225:ambient-attx4.c **** 
 226:ambient-attx4.c ****   // Disable ADC timer for now
 227:ambient-attx4.c ****   cbi(TIMSK1, OCIE1A);
 886               		.loc 2 227 0
 887 0352 6198      		cbi 0xc,1
 228:ambient-attx4.c **** 
 229:ambient-attx4.c ****   // Start up slave
 230:ambient-attx4.c ****   spiX_initslave(0);
 888               		.loc 2 230 0
 889 0354 80E0      		ldi r24,0
 890 0356 00D0      		rcall spiX_initslave
 891               	.LVL21:
 231:ambient-attx4.c **** 
 232:ambient-attx4.c ****   // Enable interrupts (SPI needs this)
 233:ambient-attx4.c ****   sei();
 892               		.loc 2 233 0
 893               	/* #APP */
 894               	 ;  233 "ambient-attx4.c" 1
 895 0358 7894      		sei
 896               	 ;  0 "" 2
 234:ambient-attx4.c **** 
 235:ambient-attx4.c ****   //re-enable USI
 236:ambient-attx4.c ****   USICR|=(1<<USIOIE)|(1<<USIWM0);
 897               		.loc 2 236 0
 898               	/* #NOAPP */
 899 035a 8DB1      		in r24,0xd
 900 035c 8065      		ori r24,lo8(80)
 901 035e 8DB9      		out 0xd,r24
 237:ambient-attx4.c **** 
 238:ambient-attx4.c ****   // put 'alive' bit
 239:ambient-attx4.c ****   spiX_put(ALIVE_CODE);
 902               		.loc 2 239 0
 903 0360 85E5      		ldi r24,lo8(85)
 904 0362 00D0      		rcall spiX_put
 905               	.LVL22:
 240:ambient-attx4.c ****   spiX_wait();
 906               		.loc 2 240 0
 907 0364 00D0      		rcall spiX_wait
 908               	.LVL23:
 909               	.LBB16:
 910               	.LBB17:
 482:spi_via_usi_driver.c **** 	return storedUSIDR;
 911               		.loc 1 482 0
 912 0366 1091 0000 		lds r17,storedUSIDR
 913               	.LVL24:
 914               	.LBE17:
 915               	.LBE16:
 241:ambient-attx4.c **** 
 242:ambient-attx4.c ****   // Grab the command
 243:ambient-attx4.c ****   char command = spiX_get();
 244:ambient-attx4.c ****   uint16_t value = -1;
 245:ambient-attx4.c **** 
 246:ambient-attx4.c ****   // Initialize variables
 247:ambient-attx4.c ****   volatile char length = 0;
 916               		.loc 2 247 0
 917 036a 188E      		std Y+24,__zero_reg__
 918               	.LVL25:
 248:ambient-attx4.c ****   DataBuffer dataBuffer;
 249:ambient-attx4.c ****   volatile uint16_t trigVal = 0;
 919               		.loc 2 249 0
 920 036c 1F8A      		std Y+23,__zero_reg__
 921 036e 1E8A      		std Y+22,__zero_reg__
 922               	.LVL26:
 250:ambient-attx4.c **** 
 251:ambient-attx4.c ****    // Confirm command
 252:ambient-attx4.c ****   spiX_put(command);
 923               		.loc 2 252 0
 924 0370 812F      		mov r24,r17
 925 0372 00D0      		rcall spiX_put
 926               	.LVL27:
 253:ambient-attx4.c **** 
 254:ambient-attx4.c ****   // Wait for it to be sent
 255:ambient-attx4.c ****   spiX_wait();
 927               		.loc 2 255 0
 928 0374 00D0      		rcall spiX_wait
 929               	.LVL28:
 256:ambient-attx4.c **** 
 257:ambient-attx4.c ****   // Switch based on the command
 258:ambient-attx4.c ****   switch(command){
 930               		.loc 2 258 0
 931 0376 E12F      		mov r30,r17
 932 0378 F0E0      		ldi r31,0
 933 037a E830      		cpi r30,8
 934 037c F105      		cpc r31,__zero_reg__
 935 037e 00F0      		brlo .+2
 936 0380 00C0      		rjmp .L50
 937 0382 E050      		subi r30,lo8(-(gs(.L57)))
 938 0384 F040      		sbci r31,hi8(-(gs(.L57)))
 939 0386 0994      		ijmp
 940               		.section	.progmem.gcc_sw_table,"ax",@progbits
 941               		.p2align	1
 942               	.L57:
 943 0000 00C0      		rjmp .L51
 944 0002 00C0      		rjmp .L52
 945 0004 00C0      		rjmp .L53
 946 0006 00C0      		rjmp .L53
 947 0008 00C0      		rjmp .L54
 948 000a 00C0      		rjmp .L54
 949 000c 00C0      		rjmp .L55
 950 000e 00C0      		rjmp .L56
 951               		.text
 952               	.L51:
 259:ambient-attx4.c **** 
 260:ambient-attx4.c ****    // ACK command checks comms
 261:ambient-attx4.c ****     case ACK_CMD:
 262:ambient-attx4.c **** 
 263:ambient-attx4.c ****       //Send ACK code
 264:ambient-attx4.c ****       spiX_put(ACK_CODE);
 953               		.loc 2 264 0
 954 0388 83E3      		ldi r24,lo8(51)
 955 038a 00C0      		rjmp .L63
 956               	.L56:
 265:ambient-attx4.c **** 
 266:ambient-attx4.c ****       // Wait for it to be sent
 267:ambient-attx4.c ****       spiX_wait();
 268:ambient-attx4.c ****       break;
 269:ambient-attx4.c **** 
 270:ambient-attx4.c ****     // If the checksum is asked for
 271:ambient-attx4.c ****     case CRC_CMD:
 272:ambient-attx4.c ****       spiX_put((checksum >> 8) & 0xff);
 957               		.loc 2 272 0
 958 038c 8091 0000 		lds r24,checksum
 959 0390 9091 0000 		lds r25,checksum+1
 960 0394 892F      		mov r24,r25
 961 0396 00D0      		rcall spiX_put
 962               	.LVL29:
 273:ambient-attx4.c ****       spiX_wait();
 963               		.loc 2 273 0
 964 0398 00D0      		rcall spiX_wait
 965               	.LVL30:
 274:ambient-attx4.c ****       spiX_put((checksum >> 0) & 0xff);
 966               		.loc 2 274 0
 967 039a 8091 0000 		lds r24,checksum
 968 039e 9091 0000 		lds r25,checksum+1
 969               	.LVL31:
 970               	.L63:
 971 03a2 00D0      		rcall spiX_put
 972               	.LVL32:
 275:ambient-attx4.c ****       spiX_wait();
 973               		.loc 2 275 0
 974 03a4 00D0      		rcall spiX_wait
 975               	.LVL33:
 276:ambient-attx4.c ****       break;
 976               		.loc 2 276 0
 977 03a6 00C0      		rjmp .L50
 978               	.LVL34:
 979               	.L52:
 277:ambient-attx4.c **** 
 278:ambient-attx4.c ****     // If they want firmware version
 279:ambient-attx4.c ****     case FIRMWARE_CMD:
 280:ambient-attx4.c ****       // Send the firmware version
 281:ambient-attx4.c ****       spiX_put(FIRMWARE_VERSION);
 980               		.loc 2 281 0
 981 03a8 83E0      		ldi r24,lo8(3)
 982 03aa 00C0      		rjmp .L63
 983               	.L53:
 282:ambient-attx4.c ****       spiX_wait();
 283:ambient-attx4.c ****       break;
 284:ambient-attx4.c **** 
 285:ambient-attx4.c ****     // Routine for reading buffers
 286:ambient-attx4.c ****     case LIGHT_CMD:
 287:ambient-attx4.c ****     case SOUND_CMD:
 288:ambient-attx4.c **** 
 289:ambient-attx4.c ****       // Grab requested buffer
 290:ambient-attx4.c ****       dataBuffer = bufferForCommand(command);
 984               		.loc 2 290 0
 985 03ac 612F      		mov r22,r17
 986 03ae 8E01      		movw r16,r28
 987 03b0 0F5F      		subi r16,-1
 988 03b2 1F4F      		sbci r17,-1
 989 03b4 C801      		movw r24,r16
 990 03b6 00D0      		rcall bufferForCommand
 991               	.LVL35:
 992               	.LBB18:
 993               	.LBB19:
 482:spi_via_usi_driver.c **** 	return storedUSIDR;
 994               		.loc 1 482 0
 995 03b8 8091 0000 		lds r24,storedUSIDR
 996               	.LBE19:
 997               	.LBE18:
 291:ambient-attx4.c ****       // Grab read length
 292:ambient-attx4.c ****       length = spiX_get();
 998               		.loc 2 292 0
 999 03bc 888F      		std Y+24,r24
 293:ambient-attx4.c **** 
 294:ambient-attx4.c ****       // Echo read length
 295:ambient-attx4.c ****       spiX_put(length);
 1000               		.loc 2 295 0
 1001 03be 888D      		ldd r24,Y+24
 1002 03c0 00D0      		rcall spiX_put
 1003               	.LVL36:
 296:ambient-attx4.c ****       // Wait for echo to complete
 297:ambient-attx4.c ****       spiX_wait();
 1004               		.loc 2 297 0
 1005 03c2 00D0      		rcall spiX_wait
 1006               	.LVL37:
 298:ambient-attx4.c **** 
 299:ambient-attx4.c ****       // Iterate through buffer
 300:ambient-attx4.c ****       // Potential Bug: Could read at one index past the last recorded value. may need to decrement
 301:ambient-attx4.c ****       for(counter=0;counter<length;counter++){
 1007               		.loc 2 301 0
 1008 03c4 1092 0000 		sts counter+1,__zero_reg__
 1009 03c8 1092 0000 		sts counter,__zero_reg__
 302:ambient-attx4.c **** 
 303:ambient-attx4.c ****          // If the buffer is at 0
 304:ambient-attx4.c ****          if (dataBuffer.bufferLocation == 0) {
 305:ambient-attx4.c **** 
 306:ambient-attx4.c ****            // Set it to the end of the buffer
 307:ambient-attx4.c ****            dataBuffer.bufferLocation = (BUF_SIZE-1);
 1010               		.loc 2 307 0
 1011 03cc 89E0      		ldi r24,lo8(9)
 1012 03ce D82E      		mov r13,r24
 308:ambient-attx4.c ****          }
 309:ambient-attx4.c **** 
 310:ambient-attx4.c ****         // Decrement buffer (we read going backwards)
 311:ambient-attx4.c ****         dataBuffer.bufferLocation--;
 312:ambient-attx4.c **** 
 313:ambient-attx4.c ****         value = dataBuffer.buffer[dataBuffer.bufferLocation];
 1013               		.loc 2 313 0
 1014 03d0 7801      		movw r14,r16
 301:ambient-attx4.c ****       for(counter=0;counter<length;counter++){
 1015               		.loc 2 301 0
 1016 03d2 00C0      		rjmp .L58
 1017               	.LVL38:
 1018               	.L60:
 304:ambient-attx4.c ****          if (dataBuffer.bufferLocation == 0) {
 1019               		.loc 2 304 0
 1020 03d4 8D89      		ldd r24,Y+21
 1021 03d6 8111      		cpse r24,__zero_reg__
 1022 03d8 00C0      		rjmp .L59
 307:ambient-attx4.c ****            dataBuffer.bufferLocation = (BUF_SIZE-1);
 1023               		.loc 2 307 0
 1024 03da DD8A      		std Y+21,r13
 1025               	.L59:
 311:ambient-attx4.c ****         dataBuffer.bufferLocation--;
 1026               		.loc 2 311 0
 1027 03dc 8D89      		ldd r24,Y+21
 1028 03de 8150      		subi r24,lo8(-(-1))
 1029 03e0 8D8B      		std Y+21,r24
 1030               		.loc 2 313 0
 1031 03e2 ED89      		ldd r30,Y+21
 1032 03e4 F0E0      		ldi r31,0
 1033 03e6 EE0F      		lsl r30
 1034 03e8 FF1F      		rol r31
 1035 03ea EE0D      		add r30,r14
 1036 03ec FF1D      		adc r31,r15
 1037 03ee 0081      		ld r16,Z
 1038 03f0 1181      		ldd r17,Z+1
 1039               	.LVL39:
 314:ambient-attx4.c **** 
 315:ambient-attx4.c ****         // Put the byte at the current location in the buffer
 316:ambient-attx4.c ****         spiX_put(value >> 8);
 1040               		.loc 2 316 0
 1041 03f2 812F      		mov r24,r17
 1042 03f4 00D0      		rcall spiX_put
 1043               	.LVL40:
 317:ambient-attx4.c **** 
 318:ambient-attx4.c ****         // Wait for it to be sent
 319:ambient-attx4.c ****         spiX_wait();
 1044               		.loc 2 319 0
 1045 03f6 00D0      		rcall spiX_wait
 1046               	.LVL41:
 320:ambient-attx4.c **** 
 321:ambient-attx4.c ****         spiX_put(value & 0xFF);
 1047               		.loc 2 321 0
 1048 03f8 802F      		mov r24,r16
 1049 03fa 00D0      		rcall spiX_put
 1050               	.LVL42:
 322:ambient-attx4.c ****         spiX_wait();
 1051               		.loc 2 322 0
 1052 03fc 00D0      		rcall spiX_wait
 1053               	.LVL43:
 301:ambient-attx4.c ****       for(counter=0;counter<length;counter++){
 1054               		.loc 2 301 0
 1055 03fe 2091 0000 		lds r18,counter
 1056 0402 3091 0000 		lds r19,counter+1
 1057 0406 2F5F      		subi r18,-1
 1058 0408 3F4F      		sbci r19,-1
 1059 040a 3093 0000 		sts counter+1,r19
 1060 040e 2093 0000 		sts counter,r18
 1061               	.LVL44:
 1062               	.L58:
 301:ambient-attx4.c ****       for(counter=0;counter<length;counter++){
 1063               		.loc 2 301 0 is_stmt 0 discriminator 1
 1064 0412 2091 0000 		lds r18,counter
 1065 0416 3091 0000 		lds r19,counter+1
 1066 041a 888D      		ldd r24,Y+24
 1067 041c 90E0      		ldi r25,0
 1068 041e 2817      		cp r18,r24
 1069 0420 3907      		cpc r19,r25
 1070 0422 04F0      		brlt .L60
 323:ambient-attx4.c ****       }
 324:ambient-attx4.c **** 
 325:ambient-attx4.c **** 
 326:ambient-attx4.c ****       // Put the stop command
 327:ambient-attx4.c ****       spiX_put(STOP_CMD);
 1071               		.loc 2 327 0 is_stmt 1
 1072 0424 86E1      		ldi r24,lo8(22)
 1073 0426 00C0      		rjmp .L63
 1074               	.LVL45:
 1075               	.L54:
 328:ambient-attx4.c **** 
 329:ambient-attx4.c ****       // Wait for it to be sent
 330:ambient-attx4.c ****       spiX_wait();
 331:ambient-attx4.c **** 
 332:ambient-attx4.c ****       break;
 333:ambient-attx4.c **** 
 334:ambient-attx4.c ****     case LIGHT_TRIGGER_CMD:
 335:ambient-attx4.c ****     case SOUND_TRIGGER_CMD:
 336:ambient-attx4.c **** 
 337:ambient-attx4.c ****       // Gather high 8 bits
 338:ambient-attx4.c ****       trigVal = (spiX_get() << 8);
 1076               		.loc 2 338 0
 1077 0428 3091 0000 		lds r19,storedUSIDR
 1078 042c 20E0      		ldi r18,0
 1079               	.LVL46:
 1080 042e 3F8B      		std Y+23,r19
 1081 0430 2E8B      		std Y+22,r18
 339:ambient-attx4.c ****       // Echo
 340:ambient-attx4.c ****       spiX_put(trigVal >> 8);
 1082               		.loc 2 340 0
 1083 0432 2E89      		ldd r18,Y+22
 1084 0434 3F89      		ldd r19,Y+23
 1085               	.LVL47:
 1086 0436 832F      		mov r24,r19
 1087 0438 00D0      		rcall spiX_put
 1088               	.LVL48:
 341:ambient-attx4.c ****       spiX_wait();
 1089               		.loc 2 341 0
 1090 043a 00D0      		rcall spiX_wait
 1091               	.LVL49:
 342:ambient-attx4.c **** 
 343:ambient-attx4.c ****       // Gather low 8 bits
 344:ambient-attx4.c ****       trigVal |= (spiX_get());
 1092               		.loc 2 344 0
 1093 043c 2E89      		ldd r18,Y+22
 1094 043e 3F89      		ldd r19,Y+23
 1095 0440 8091 0000 		lds r24,storedUSIDR
 1096 0444 282B      		or r18,r24
 1097               	.LVL50:
 1098 0446 3F8B      		std Y+23,r19
 1099 0448 2E8B      		std Y+22,r18
 345:ambient-attx4.c ****       //Echo
 346:ambient-attx4.c ****       spiX_put(trigVal & 0xFF);
 1100               		.loc 2 346 0
 1101 044a 8E89      		ldd r24,Y+22
 1102 044c 9F89      		ldd r25,Y+23
 1103 044e 00D0      		rcall spiX_put
 1104               	.LVL51:
 347:ambient-attx4.c ****       spiX_wait();
 1105               		.loc 2 347 0
 1106 0450 00D0      		rcall spiX_wait
 1107               	.LVL52:
 1108               	.LBB20:
 1109               	.LBB21:
 180:ambient-attx4.c ****   if (command == LIGHT_TRIGGER_CMD) {
 1110               		.loc 2 180 0
 1111 0452 1430      		cpi r17,lo8(4)
 1112 0454 01F4      		brne .L62
 181:ambient-attx4.c ****     return &lightTrigger;
 1113               		.loc 2 181 0
 1114 0456 E0E0      		ldi r30,lo8(lightTrigger)
 1115 0458 F0E0      		ldi r31,hi8(lightTrigger)
 1116 045a 00C0      		rjmp .L61
 1117               	.L62:
 184:ambient-attx4.c ****     return &soundTrigger;
 1118               		.loc 2 184 0
 1119 045c E0E0      		ldi r30,lo8(soundTrigger)
 1120 045e F0E0      		ldi r31,hi8(soundTrigger)
 1121               	.L61:
 1122               	.LBE21:
 1123               	.LBE20:
 348:ambient-attx4.c **** 
 349:ambient-attx4.c ****       *(triggerValueForCommand(command)) = trigVal;
 1124               		.loc 2 349 0
 1125 0460 8E89      		ldd r24,Y+22
 1126 0462 9F89      		ldd r25,Y+23
 1127 0464 9183      		std Z+1,r25
 1128 0466 8083      		st Z,r24
 350:ambient-attx4.c ****       break;
 1129               		.loc 2 350 0
 1130 0468 00C0      		rjmp .L50
 1131               	.LVL53:
 1132               	.L55:
 351:ambient-attx4.c **** 
 352:ambient-attx4.c ****    case TRIGGER_FETCH_CMD:
 353:ambient-attx4.c ****       // Put Light Trigger Val
 354:ambient-attx4.c ****       spiX_put(lightTriggerReadVal >> 8);
 1133               		.loc 2 354 0
 1134 046a 8091 0000 		lds r24,lightTriggerReadVal
 1135 046e 9091 0000 		lds r25,lightTriggerReadVal+1
 1136 0472 892F      		mov r24,r25
 1137 0474 00D0      		rcall spiX_put
 1138               	.LVL54:
 355:ambient-attx4.c **** 
 356:ambient-attx4.c ****       // Wait for it to go through
 357:ambient-attx4.c ****       spiX_wait();
 1139               		.loc 2 357 0
 1140 0476 00D0      		rcall spiX_wait
 1141               	.LVL55:
 358:ambient-attx4.c **** 
 359:ambient-attx4.c ****       spiX_put(lightTriggerReadVal & 0xFF);
 1142               		.loc 2 359 0
 1143 0478 8091 0000 		lds r24,lightTriggerReadVal
 1144 047c 9091 0000 		lds r25,lightTriggerReadVal+1
 1145 0480 00D0      		rcall spiX_put
 1146               	.LVL56:
 360:ambient-attx4.c **** 
 361:ambient-attx4.c ****       // Wait for it to go through
 362:ambient-attx4.c ****       spiX_wait();
 1147               		.loc 2 362 0
 1148 0482 00D0      		rcall spiX_wait
 1149               	.LVL57:
 363:ambient-attx4.c **** 
 364:ambient-attx4.c ****       // Clear it
 365:ambient-attx4.c ****       lightTriggerReadVal = 0;
 1150               		.loc 2 365 0
 1151 0484 1092 0000 		sts lightTriggerReadVal+1,__zero_reg__
 1152 0488 1092 0000 		sts lightTriggerReadVal,__zero_reg__
 366:ambient-attx4.c **** 
 367:ambient-attx4.c ****       // Put Loudnesss Trigger Val
 368:ambient-attx4.c ****       spiX_put(soundTriggerReadVal >> 8);
 1153               		.loc 2 368 0
 1154 048c 8091 0000 		lds r24,soundTriggerReadVal
 1155 0490 9091 0000 		lds r25,soundTriggerReadVal+1
 1156 0494 892F      		mov r24,r25
 1157 0496 00D0      		rcall spiX_put
 1158               	.LVL58:
 369:ambient-attx4.c **** 
 370:ambient-attx4.c ****       // Wait for it to be sent
 371:ambient-attx4.c ****       spiX_wait();
 1159               		.loc 2 371 0
 1160 0498 00D0      		rcall spiX_wait
 1161               	.LVL59:
 372:ambient-attx4.c **** 
 373:ambient-attx4.c ****         // Put Loudnesss Trigger Val
 374:ambient-attx4.c ****       spiX_put(soundTriggerReadVal & 0xFF);
 1162               		.loc 2 374 0
 1163 049a 8091 0000 		lds r24,soundTriggerReadVal
 1164 049e 9091 0000 		lds r25,soundTriggerReadVal+1
 1165 04a2 00D0      		rcall spiX_put
 1166               	.LVL60:
 375:ambient-attx4.c **** 
 376:ambient-attx4.c ****       // Wait for it to go through
 377:ambient-attx4.c ****       spiX_wait();
 1167               		.loc 2 377 0
 1168 04a4 00D0      		rcall spiX_wait
 1169               	.LVL61:
 378:ambient-attx4.c **** 
 379:ambient-attx4.c ****       // Clear it
 380:ambient-attx4.c ****       soundTriggerReadVal = 0;
 1170               		.loc 2 380 0
 1171 04a6 1092 0000 		sts soundTriggerReadVal+1,__zero_reg__
 1172 04aa 1092 0000 		sts soundTriggerReadVal,__zero_reg__
 381:ambient-attx4.c **** 
 382:ambient-attx4.c ****       // Clear IRQ
 383:ambient-attx4.c ****       cbi(PORTB, IRQ_PIN);
 1173               		.loc 2 383 0
 1174 04ae C198      		cbi 0x18,1
 1175               	.LVL62:
 1176               	.L50:
 384:ambient-attx4.c **** 
 385:ambient-attx4.c ****       break;
 386:ambient-attx4.c ****  }
 387:ambient-attx4.c **** 
 388:ambient-attx4.c ****   // Disable USI
 389:ambient-attx4.c ****   USICR&= ~(1<<USIOIE);
 1177               		.loc 2 389 0
 1178 04b0 6E98      		cbi 0xd,6
 390:ambient-attx4.c ****   USICR&= ~(1<<USIWM0);
 1179               		.loc 2 390 0
 1180 04b2 6C98      		cbi 0xd,4
 391:ambient-attx4.c **** 
 392:ambient-attx4.c ****   cbi(DDRA, MOSI);
 1181               		.loc 2 392 0
 1182 04b4 D698      		cbi 0x1a,6
 393:ambient-attx4.c ****   cbi(DDRA, MISO);
 1183               		.loc 2 393 0
 1184 04b6 D598      		cbi 0x1a,5
 394:ambient-attx4.c **** 
 395:ambient-attx4.c ****   // Re-enable ADC reads
 396:ambient-attx4.c ****   sbi(TIMSK1, OCIE1A);
 1185               		.loc 2 396 0
 1186 04b8 619A      		sbi 0xc,1
 1187               	/* epilogue start */
 397:ambient-attx4.c **** }
 1188               		.loc 2 397 0
 1189 04ba C85E      		subi r28,lo8(-(24))
 1190 04bc CDBF      		out __SP_L__,r28
 1191 04be DF91      		pop r29
 1192 04c0 CF91      		pop r28
 1193 04c2 FF91      		pop r31
 1194 04c4 EF91      		pop r30
 1195 04c6 BF91      		pop r27
 1196 04c8 AF91      		pop r26
 1197 04ca 9F91      		pop r25
 1198 04cc 8F91      		pop r24
 1199 04ce 7F91      		pop r23
 1200 04d0 6F91      		pop r22
 1201 04d2 5F91      		pop r21
 1202 04d4 4F91      		pop r20
 1203 04d6 3F91      		pop r19
 1204 04d8 2F91      		pop r18
 1205 04da 1F91      		pop r17
 1206 04dc 0F91      		pop r16
 1207 04de FF90      		pop r15
 1208 04e0 EF90      		pop r14
 1209 04e2 DF90      		pop r13
 1210 04e4 0F90      		pop r0
 1211 04e6 0FBE      		out __SREG__,r0
 1212 04e8 0F90      		pop r0
 1213 04ea 1F90      		pop r1
 1214 04ec 1895      		reti
 1215               		.cfi_endproc
 1216               	.LFE18:
 1218               	.global	crc16
 1220               	crc16:
 1221               	.LFB19:
 398:ambient-attx4.c **** 
 399:ambient-attx4.c **** unsigned short crc16( unsigned short length)
 400:ambient-attx4.c **** {
 1222               		.loc 2 400 0
 1223               		.cfi_startproc
 1224               	.LVL63:
 1225               	/* prologue: function */
 1226               	/* frame size = 0 */
 1227               	/* stack size = 0 */
 1228               	.L__stack_usage = 0
 401:ambient-attx4.c ****       unsigned char i;
 402:ambient-attx4.c ****       unsigned int data;
 403:ambient-attx4.c ****       unsigned int crc = 0xffff;
 404:ambient-attx4.c ****       char *data_p = 0x0000;
 405:ambient-attx4.c **** 
 406:ambient-attx4.c ****       if (length == 0)
 1229               		.loc 2 406 0
 1230 04ee 0097      		sbiw r24,0
 1231 04f0 01F0      		breq .L70
 399:ambient-attx4.c **** unsigned short crc16( unsigned short length)
 1232               		.loc 2 399 0
 1233 04f2 40E0      		ldi r20,0
 1234 04f4 50E0      		ldi r21,0
 1235 04f6 2FEF      		ldi r18,lo8(-1)
 1236 04f8 3FEF      		ldi r19,lo8(-1)
 1237               	.LVL64:
 1238               	.L69:
 1239               	.LBB22:
 407:ambient-attx4.c ****             return (~crc);
 408:ambient-attx4.c ****       do
 409:ambient-attx4.c ****       {
 410:ambient-attx4.c ****             for (i=0, data= pgm_read_byte(data_p++);
 1240               		.loc 2 410 0
 1241 04fa FA01      		movw r30,r20
 1242               	.LVL65:
 1243 04fc 4F5F      		subi r20,-1
 1244 04fe 5F4F      		sbci r21,-1
 1245               	.LVL66:
 1246               	/* #APP */
 1247               	 ;  410 "ambient-attx4.c" 1
 1248 0500 E491      		lpm r30, Z
 1249               		
 1250               	 ;  0 "" 2
 1251               	.LVL67:
 1252               	/* #NOAPP */
 1253               	.LBE22:
 1254 0502 F0E0      		ldi r31,0
 1255               	.LVL68:
 1256 0504 A8E0      		ldi r26,lo8(8)
 1257               	.LVL69:
 1258               	.L68:
 411:ambient-attx4.c ****                  i < 8;
 412:ambient-attx4.c ****                  i++, data >>= 1)
 413:ambient-attx4.c ****             {
 414:ambient-attx4.c ****                   if ((crc & 0x0001) ^ (data & 0x0001))
 1259               		.loc 2 414 0
 1260 0506 B901      		movw r22,r18
 1261 0508 6E27      		eor r22,r30
 1262 050a 7F27      		eor r23,r31
 1263 050c 3695      		lsr r19
 1264 050e 2795      		ror r18
 1265               	.LVL70:
 1266 0510 60FF      		sbrs r22,0
 1267 0512 00C0      		rjmp .L67
 415:ambient-attx4.c ****                         crc = (crc >> 1) ^ POLY;
 1268               		.loc 2 415 0
 1269 0514 68E0      		ldi r22,8
 1270 0516 2627      		eor r18,r22
 1271 0518 64E8      		ldi r22,132
 1272 051a 3627      		eor r19,r22
 1273               	.LVL71:
 1274               	.L67:
 412:ambient-attx4.c ****                  i++, data >>= 1)
 1275               		.loc 2 412 0
 1276 051c F695      		lsr r31
 1277 051e E795      		ror r30
 1278               	.LVL72:
 1279 0520 A150      		subi r26,lo8(-(-1))
 410:ambient-attx4.c ****             for (i=0, data= pgm_read_byte(data_p++);
 1280               		.loc 2 410 0
 1281 0522 01F4      		brne .L68
 416:ambient-attx4.c ****                   else  crc >>= 1;
 417:ambient-attx4.c ****             }
 418:ambient-attx4.c ****       } while (--length);
 1282               		.loc 2 418 0
 1283 0524 4817      		cp r20,r24
 1284 0526 5907      		cpc r21,r25
 1285 0528 01F4      		brne .L69
 419:ambient-attx4.c ****       crc = ~crc;
 1286               		.loc 2 419 0
 1287 052a 2095      		com r18
 1288 052c 3095      		com r19
 1289               	.LVL73:
 420:ambient-attx4.c ****       data = crc;
 421:ambient-attx4.c ****       crc = (crc << 8) | (data >> 8 & 0xff);
 1290               		.loc 2 421 0
 1291 052e 3227      		eor r19,r18
 1292 0530 2327      		eor r18,r19
 1293               	.LVL74:
 1294 0532 3227      		eor r19,r18
 1295               	.LVL75:
 422:ambient-attx4.c **** 
 423:ambient-attx4.c ****       return (crc);
 1296               		.loc 2 423 0
 1297 0534 00C0      		rjmp .L65
 1298               	.LVL76:
 1299               	.L70:
 407:ambient-attx4.c ****             return (~crc);
 1300               		.loc 2 407 0
 1301 0536 20E0      		ldi r18,0
 1302 0538 30E0      		ldi r19,0
 1303               	.LVL77:
 1304               	.L65:
 424:ambient-attx4.c **** }
 1305               		.loc 2 424 0
 1306 053a C901      		movw r24,r18
 1307 053c 0895      		ret
 1308               		.cfi_endproc
 1309               	.LFE19:
 1311               		.section	.text.startup,"ax",@progbits
 1312               	.global	main
 1314               	main:
 1315               	.LFB8:
  43:ambient-attx4.c **** int main(void) {
 1316               		.loc 2 43 0
 1317               		.cfi_startproc
 1318               	/* prologue: function */
 1319               	/* frame size = 0 */
 1320               	/* stack size = 0 */
 1321               	.L__stack_usage = 0
  44:ambient-attx4.c ****   checksum = crc16( (unsigned short) _exit << 1 );
 1322               		.loc 2 44 0
 1323 0000 80E0      		ldi r24,lo8(gs(_exit))
 1324 0002 90E0      		ldi r25,hi8(gs(_exit))
 1325 0004 880F      		lsl r24
 1326 0006 991F      		rol r25
 1327 0008 00D0      		rcall crc16
 1328               	.LVL78:
 1329 000a 9093 0000 		sts checksum+1,r25
 1330 000e 8093 0000 		sts checksum,r24
  46:ambient-attx4.c ****   setup();
 1331               		.loc 2 46 0
 1332 0012 00D0      		rcall setup
 1333               	.LVL79:
 1334               	.L74:
 1335 0014 00C0      		rjmp .L74
 1336               		.cfi_endproc
 1337               	.LFE8:
 1339               		.comm	SoundBuffer,21,1
 1340               		.comm	LightBuffer,21,1
 1341               	.global	checksum
 1342               		.data
 1345               	checksum:
 1346 0000 FFFF      		.word	-1
 1347               	.global	soundTriggerReadVal
 1348               		.section .bss
 1351               	soundTriggerReadVal:
 1352 0000 0000      		.zero	2
 1353               	.global	soundTrigger
 1356               	soundTrigger:
 1357 0002 0000      		.zero	2
 1358               	.global	lightTriggerReadVal
 1361               	lightTriggerReadVal:
 1362 0004 0000      		.zero	2
 1363               	.global	lightTrigger
 1366               	lightTrigger:
 1367 0006 0000      		.zero	2
 1368               	.global	counter
 1371               	counter:
 1372 0008 0000      		.zero	2
 1373               		.comm	spiX_status,1,1
 1374               		.comm	storedUSIDR,1,1
 1375               		.text
 1376               	.Letext0:
 1377               		.file 3 "/usr/local/Cellar/avr-gcc/4.7.2/lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 1378               		.file 4 "ambient-attx4.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ambient-attx4.c
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:2      *ABS*:000000000000003d __SP_L__
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:3      *ABS*:000000000000003f __SREG__
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:4      *ABS*:0000000000000000 __tmp_reg__
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:5      *ABS*:0000000000000001 __zero_reg__
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:11     .text:0000000000000000 __vector_9
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:45     .text:0000000000000016 __vector_16
                            *COM*:0000000000000001 spiX_status
                            *COM*:0000000000000001 storedUSIDR
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:100    .text:0000000000000050 spiX_initmaster
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:153    .text:0000000000000094 spiX_initslave
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:200    .text:00000000000000d0 spiX_put
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:265    .text:000000000000011e spiX_get
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:281    .text:0000000000000124 spiX_wait
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:302    .text:000000000000012e setupIO
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:327    .text:000000000000013a enableSPI
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:356    .text:000000000000014e setupTimer
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:385    .text:0000000000000166 prepareADC
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:413    .text:0000000000000178 setup
                            *COM*:0000000000000015 LightBuffer
                            *COM*:0000000000000015 SoundBuffer
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:455    .text:000000000000018e analogRead
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:499    .text:00000000000001b4 bufferForCommand
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:535    .text:00000000000001d0 triggerValueForCommand
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1366   .bss:0000000000000006 lightTrigger
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1356   .bss:0000000000000002 soundTrigger
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:565    .text:00000000000001e2 __vector_6
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1361   .bss:0000000000000004 lightTriggerReadVal
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1351   .bss:0000000000000000 soundTriggerReadVal
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:783    .text:000000000000031a __vector_1
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1345   .data:0000000000000000 checksum
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1371   .bss:0000000000000008 counter
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1220   .text:00000000000004ee crc16
/var/folders/l9/mxp5wgg1719gzb1vcxzq4s6w0000gn/T//ccrrQRCX.s:1314   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
_exit
__do_copy_data
__do_clear_bss
